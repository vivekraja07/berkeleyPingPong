<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ player_name }} - Statistics</title>
    {% if google_analytics_id %}
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id={{ google_analytics_id }}"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', '{{ google_analytics_id }}');
    </script>
    {% endif %}
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lobster|PT+Sans+Narrow:400,700">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'PT Sans Narrow', sans-serif;
            background: #ffffff;
            color: #444;
            line-height: 1.4;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        header {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 30px;
            margin-bottom: 30px;
        }
        
        header h1 {
            font-family: 'Lobster', cursive;
            color: #405060;
            font-size: 3.5em;
            margin-bottom: 15px;
            text-align: center;
        }
        
        header a {
            color: #607890;
            text-decoration: none;
            font-weight: 700;
        }
        
        header a:hover {
            color: #036;
            text-decoration: underline;
        }
        
        .stats-cards {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .stat-card .value.small {
            font-size: 1.2em;
        }
        
        .stat-card .value.extra-small {
            font-size: 1.5em;
        }
        
        .stat-card {
            background: #fff;
            border: 1px solid #dee2e6;
            padding: 12px 15px;
            text-align: center;
        }
        
        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
            color: #607890;
            margin-bottom: 6px;
        }
        
        .stat-card.wins .value {
            color: #28a745;
        }
        
        .stat-card.losses .value {
            color: #dc3545;
        }
        
        .stat-card .label {
            color: #444;
            font-size: 0.95em;
        }
        
        .stat-card .sub-info {
            font-size: 0.85em;
            color: #444;
            margin-top: 3px;
        }
        
        .stats-row {
            display: grid;
            gap: 18px;
            width: 100%;
        }
        
        .stats-row.row-1 {
            grid-template-columns: repeat(4, 1fr);
        }
        
        .stats-row.row-2 {
            grid-template-columns: repeat(4, 1fr);
        }
        
        .stats-row.row-3 {
            grid-template-columns: repeat(2, 1fr);
        }
        
        .stat-card.current-rating,
        .stat-card.highest-rating {
            background: #f0f4f8;
            border: 2px solid #405060;
        }
        
        .stat-card.current-rating .value,
        .stat-card.highest-rating .value {
            font-size: 2em;
            font-weight: 900;
            color: #405060;
        }
        
        @media (max-width: 768px) {
            .stats-row.row-1,
            .stats-row.row-2,
            .stats-row.row-3 {
                grid-template-columns: 1fr;
            }
        }
        
        .chart-container {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .chart-container h2 {
            font-family: 'Lobster', cursive;
            color: #444;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 2px solid #607890;
            padding-bottom: 10px;
        }
        
        .chart-wrapper {
            position: relative;
            height: 400px;
            margin-bottom: 20px;
        }
        
        .matches-table {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 30px;
            margin-bottom: 30px;
            overflow-x: auto;
        }
        
        .matches-table h2 {
            font-family: 'Lobster', cursive;
            color: #444;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 2px solid #607890;
            padding-bottom: 10px;
        }
        
        .timeline-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .timeline-btn {
            padding: 8px 16px;
            border: 2px solid #607890;
            background: #fff;
            color: #607890;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 700;
            transition: all 0.3s;
        }
        
        .timeline-btn:hover {
            background: #f0f0f0;
        }
        
        .timeline-btn.active {
            background: #607890;
            color: #fff;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: #fff;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
            color: #444;
        }
        
        th {
            background: #f8f9fa;
            font-weight: 700;
            color: #444;
        }
        
        tr:hover {
            background: #f8f9fa;
        }
        
        .win {
            color: #28a745;
            font-weight: 600;
        }
        
        .loss {
            color: #dc3545;
            font-weight: 600;
        }
        
        .loading {
            text-align: center;
            color: #444;
            font-size: 1.2em;
            padding: 40px;
        }
        
        .error {
            background: #dc3545;
            color: white;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }
        
        .no-data {
            text-align: center;
            color: #444;
            padding: 40px;
            font-size: 1.1em;
        }
        
        .pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding: 15px 0;
            border-top: 1px solid #404040;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        @media (max-width: 768px) {
            .pagination {
                flex-direction: column;
                align-items: stretch;
            }
            
            .pagination-info {
                text-align: center;
            }
            
            .pagination-controls {
                justify-content: center;
            }
        }
        
        .pagination-info {
            color: #444;
            font-size: 0.9em;
        }
        
        .pagination-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .pagination-btn {
            padding: 8px 16px;
            border: 2px solid #607890;
            background: #fff;
            color: #607890;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 700;
            transition: all 0.3s;
        }
        
        .pagination-btn:hover:not(:disabled) {
            background: #f0f0f0;
        }
        
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination-btn.active {
            background: #607890;
            color: #fff;
        }
        
        .page-numbers {
            display: flex;
            gap: 5px;
        }
        
        .page-number {
            min-width: 36px;
            padding: 8px 12px;
            border: 2px solid #607890;
            background: #fff;
            color: #607890;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 700;
            text-align: center;
            transition: all 0.3s;
        }
        
        .page-number:hover {
            background: #f0f0f0;
        }
        
        .page-number.active {
            background: #607890;
            color: #fff;
        }
        
        .tournament-selector {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .tournament-selector label {
            color: #444;
        }
        
        .head-to-head-selector {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .head-to-head-selector label {
            color: #444;
        }
        
        .tournament-date-link {
            color: #607890;
            text-decoration: none;
            transition: color 0.3s;
        }
        
        .tournament-date-link:hover {
            color: #036;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            header h1 {
                font-size: 2em;
            }
        }
        
        .opponent-select {
            width: 100%;
            padding: 10px 35px 10px 15px;
            border: 2px solid #607890;
            background-color: #fff;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23444' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            color: #444;
            border-radius: 4px;
            font-size: 1em;
            font-weight: 700;
            transition: all 0.3s;
            cursor: pointer;
            min-width: 250px;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        
        .opponent-select:hover {
            background-color: #f0f0f0;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23444' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
        }
        
        .opponent-select:focus {
            outline: none;
            border-color: #036;
            background-color: #fff;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23444' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
        }
        
        .opponent-select option {
            background: #fff;
            color: #444;
            padding: 10px;
        }
        
        .head-to-head-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: #fff;
            border: 1px solid #dee2e6;
        }
        
        .h2h-stat {
            text-align: center;
        }
        
        .h2h-stat .value {
            font-size: 2em;
            font-weight: bold;
            color: #607890;
            margin-bottom: 5px;
        }
        
        .h2h-stat .label {
            color: #444;
            font-size: 0.9em;
        }
        
        .h2h-stat-win .value {
            color: #28a745;
        }
        
        .h2h-stat-loss .value {
            color: #dc3545;
        }
        
        .searchable-dropdown {
            position: relative;
            min-width: 250px;
        }
        
        .searchable-dropdown-input {
            width: 100%;
            padding: 10px 15px;
            border: 2px solid #607890;
            background: #fff;
            color: #444;
            border-radius: 4px;
            font-size: 1em;
            font-weight: 700;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .searchable-dropdown-input:hover {
            background: #f0f0f0;
        }
        
        .searchable-dropdown-input:focus {
            outline: none;
            border-color: #036;
            background: #fff;
        }
        
        .searchable-dropdown-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #fff;
            border: 2px solid #607890;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .searchable-dropdown-list.show {
            display: block;
        }
        
        .searchable-dropdown-item {
            padding: 10px 15px;
            color: #444;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .searchable-dropdown-item:hover {
            background: #f0f0f0;
        }
        
        .searchable-dropdown-item.selected {
            background: #607890;
            color: #fff;
        }
        
        .searchable-dropdown-item.no-results {
            color: #444;
            cursor: default;
            font-style: italic;
        }
        
        .searchable-dropdown-item.no-results:hover {
            background: #fff;
        }
        
        .pagination {
            border-top: 1px solid #dee2e6;
        }
        
        /* Navigation */
        nav {
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            padding: 15px 0;
            margin-bottom: 30px;
        }
        
        nav .container {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }
        
        nav a {
            color: #444;
            text-decoration: none;
            font-weight: 700;
            font-size: 1.1em;
            padding: 8px 15px;
            border-radius: 4px;
            transition: all 0.3s;
        }
        
        nav a:hover {
            background: #e9ecef;
            color: #607890;
        }
        
        nav a.active {
            color: #607890;
            border-bottom: 2px solid #607890;
        }
        
        /* Section Navigation */
        .section-nav {
            position: sticky;
            top: 0;
            background: #fff;
            border-bottom: 2px solid #607890;
            padding: 10px 0;
            margin-bottom: 20px;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
        }
        
        .section-nav.show {
            display: block;
        }
        
        .section-nav-list {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            list-style: none;
        }
        
        .section-nav-item {
            margin: 0;
        }
        
        .section-nav-link {
            color: #444;
            text-decoration: none;
            font-weight: 700;
            font-size: 0.9em;
            padding: 5px 10px;
            border-radius: 4px;
            transition: all 0.3s;
            white-space: nowrap;
        }
        
        .section-nav-link:hover {
            background: #f0f0f0;
            color: #607890;
        }
        
        .section-nav-link.active {
            background: #607890;
            color: #fff;
        }
        
        /* Back to Top Button */
        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #607890;
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.5em;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.3s;
            z-index: 99;
        }
        
        .back-to-top.show {
            display: flex;
        }
        
        .back-to-top:hover {
            background: #405060;
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }
        
        /* Section anchors with scroll offset */
        .section-anchor {
            scroll-margin-top: 80px;
        }
        
        /* Tournament Calendar Styles */
        .tournament-calendar {
            overflow-x: auto;
        }
        
        .calendar-year {
            margin-bottom: 40px;
        }
        
        .calendar-year h3 {
            font-family: 'Lobster', cursive;
            color: #444;
            font-size: 1.5em;
            margin-bottom: 15px;
            border-bottom: 2px solid #607890;
            padding-bottom: 8px;
        }
        
        .calendar-months {
            display: grid;
            grid-template-columns: repeat(12, minmax(0, 1fr));
            gap: 4px;
            margin-bottom: 20px;
        }
        
        .calendar-month {
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        
        .calendar-month-header {
            background: #f8f9fa;
            font-weight: 700;
            color: #444;
            padding: 3px 4px;
            text-align: center;
            border: 1px solid #dee2e6;
            margin-bottom: 2px;
            font-size: 0.75em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .calendar-month-dates {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-height: 20px;
        }
        
        .calendar-date {
            display: block;
            padding: 2px 3px;
            border-radius: 2px;
            text-decoration: none;
            color: #fff;
            font-weight: 700;
            text-align: center;
            transition: all 0.2s;
            font-size: 0.7em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .calendar-date.attended {
            background-color: #28a745;
            color: #fff;
        }
        
        .calendar-date.not-attended {
            background-color: #e9ecef;
            color: #6c757d;
        }
        
        .calendar-date:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }
        
        .calendar-date.attended:hover {
            background-color: #218838;
        }
        
        .calendar-date.not-attended:hover {
            background-color: #dee2e6;
            color: #495057;
        }
        
        @media (max-width: 992px) {
            .calendar-months {
                grid-template-columns: repeat(12, minmax(0, 1fr));
                gap: 3px;
            }
            .calendar-month-header {
                font-size: 0.7em;
                padding: 2px 3px;
            }
            .calendar-date {
                font-size: 0.65em;
                padding: 2px;
            }
        }
        
        @media (max-width: 768px) {
            .calendar-months {
                grid-template-columns: repeat(12, minmax(0, 1fr));
                gap: 2px;
            }
            .calendar-month-header {
                font-size: 0.65em;
                padding: 2px;
            }
            .calendar-date {
                font-size: 0.6em;
                padding: 1px 2px;
            }
        }
        
        @media (max-width: 576px) {
            .calendar-months {
                grid-template-columns: repeat(6, minmax(0, 1fr));
            }
        }
        
        @media (max-width: 400px) {
            .calendar-months {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }
        }
    </style>
</head>
<body>
    <nav>
        <div class="container">
            <a href="/">Players</a>
            <a href="/tournaments">Tournaments</a>
        </div>
    </nav>
    
    <div class="container">
        <header>
            <h1>{{ player_name }}</h1>
            <a href="/">← Back to All Players</a>
        </header>
        
        <div id="loading" class="loading">Loading statistics...</div>
        <div id="error" class="error" style="display: none;"></div>
        
        <div id="content" style="display: none;">
            <nav class="section-nav" id="sectionNav">
                <ul class="section-nav-list">
                    <li class="section-nav-item"><a href="#stats" class="section-nav-link">Stats</a></li>
                    <li class="section-nav-item"><a href="#rating-chart" class="section-nav-link">Rating</a></li>
                    <li class="section-nav-item"><a href="#performance-chart" class="section-nav-link">Performance</a></li>
                    <li class="section-nav-item"><a href="#matches" class="section-nav-link">Matches</a></li>
                    <li class="section-nav-item"><a href="#head-to-head" class="section-nav-link">Head-to-Head</a></li>
                    <li class="section-nav-item"><a href="#calendar" class="section-nav-link">Calendar</a></li>
                </ul>
            </nav>
            
            <div class="stats-cards section-anchor" id="stats">
                <div id="statsCards"></div>
            </div>
            
            <div class="chart-container section-anchor" id="rating-chart">
                <h2>Rating Over Time <span id="ratingChangeIndicator" style="font-size: 0.7em; font-weight: normal; margin-left: 10px;"></span></h2>
                <div class="timeline-selector">
                    <button class="timeline-btn" data-days="180" onclick="updateChart(180)">6 Months</button>
                    <button class="timeline-btn" data-days="365" onclick="updateChart(365)">1 Year</button>
                    <button class="timeline-btn active" data-days="null" onclick="updateChart(null)">All Time</button>
                </div>
                <div class="chart-wrapper">
                    <canvas id="ratingChart"></canvas>
                </div>
                <p style="font-size: 0.85em; color: #6c757d; margin-top: 10px; margin-bottom: 0; text-align: center; font-style: italic;">
                    Click and drag to explore • Hold Ctrl and scroll to zoom in
                </p>
            </div>
            
            <div class="chart-container section-anchor" id="performance-chart">
                <h2>Performance vs Rating Ranges</h2>
                <div class="chart-wrapper">
                    <canvas id="performanceChart"></canvas>
                </div>
            </div>
            
            <div class="matches-table section-anchor" id="matches">
                <h2>Recent Matches</h2>
                <div class="tournament-selector">
                    <label for="tournamentSelect" style="margin-right: 10px;">Tournament:</label>
                    <div class="searchable-dropdown" id="tournamentDropdown">
                        <input type="text" 
                               id="tournamentSelect" 
                               class="searchable-dropdown-input" 
                               placeholder="-- Loading tournaments --"
                               autocomplete="off">
                        <div class="searchable-dropdown-list" id="tournamentDropdownList"></div>
                    </div>
                </div>
                <div id="matchesStats" style="margin-bottom: 20px;"></div>
                <div id="matchesTable"></div>
                <div id="pagination" class="pagination" style="display: none;"></div>
            </div>
            
            <div class="matches-table section-anchor" id="head-to-head" style="margin-top: 30px;">
                <h2>Head-to-Head</h2>
                <div class="head-to-head-selector">
                    <label for="opponentSelect" style="margin-right: 10px;">Select Opponent:</label>
                    <div class="searchable-dropdown" id="opponentDropdown">
                        <input type="text" 
                               id="opponentSelect" 
                               class="searchable-dropdown-input" 
                               placeholder="-- Loading opponents --"
                               autocomplete="off"
                               readonly>
                        <div class="searchable-dropdown-list" id="opponentDropdownList"></div>
                    </div>
                </div>
                <div id="headToHeadTable" style="margin-top: 20px;"></div>
                <div id="h2hPagination" class="pagination" style="display: none;"></div>
            </div>
            
            <div class="chart-container section-anchor" id="calendar" style="margin-top: 30px;">
                <h2>Tournament Attendance Calendar</h2>
                <div id="tournamentCalendar"></div>
            </div>
        </div>
    </div>
    
    <button class="back-to-top" id="backToTop" title="Back to top">↑</button>
    
    <script>
        const playerName = {{ player_name|tojson }};
        let ratingChart = null;
        let performanceChart = null;
        let allRatingData = null;
        let currentPage = 1;
        let chartDaysBack = null; // Default to all time
        let currentDaysBack = null; // No filter for matches
        let currentTournamentId = null; // Current tournament filter
        let pageSize = 20;
        let totalMatches = 0;
        let totalPages = 0;
        let tournaments = [];
        let opponentSelectListenerAdded = false;
        let allOpponents = [];
        let selectedOpponent = null;
        let filteredOpponents = [];
        let highlightedIndex = -1;
        let h2hCurrentPage = 1;
        let h2hTotalMatches = 0;
        let h2hTotalPages = 0;
        let h2hPageSize = 20;
        let allTimeTopRatedWin = null; // Store all-time top-rated win (never changes)
        let allTimeTopRatedWinInfo = null; // Store all-time top-rated win info
        
        async function loadPlayerData() {
            try {
                // Show content immediately (progressive loading)
                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';
                
                // Load each component independently - display as soon as ready
                // 1. Rating history (fast, show chart immediately)
                fetch(`/api/player/${encodeURIComponent(playerName)}/rating-history`)
                    .then(r => r.json())
                    .then(ratingHistory => {
                        if (ratingHistory.error) {
                            console.error('Error loading rating history:', ratingHistory.error);
                            return;
                        }
                        allRatingData = ratingHistory;
                        displayRatingChart(ratingHistory, chartDaysBack);
                        if (chartDaysBack === undefined) {
                            chartDaysBack = null;
                        }
                    })
                    .catch(error => {
                        console.error('Error loading rating history:', error);
                    });
                
                // 2. Match stats (fast initial load without top-rated win)
                fetch(`/api/player/${encodeURIComponent(playerName)}/match-stats`)
                    .then(r => r.json())
                    .then(matchStats => {
                        if (matchStats.error) {
                            console.error('Error loading match stats:', matchStats.error);
                            return;
                        }
                        
                        // Debug: log the stats from initial load
                        console.log('=== INITIAL STATS DEBUG ===');
                        console.log('Full stats object:', JSON.stringify(matchStats, null, 2));
                        console.log('Highest rating:', matchStats.highest_rating, 'Type:', typeof matchStats.highest_rating);
                        console.log('Top rated win:', matchStats.top_rated_win, 'Type:', typeof matchStats.top_rated_win);
                        console.log('Date joined:', matchStats.date_joined, 'Type:', typeof matchStats.date_joined);
                        console.log('Last match date:', matchStats.last_match_date, 'Type:', typeof matchStats.last_match_date);
                        if (matchStats._debug) {
                            console.log('Debug info:', matchStats._debug);
                        }
                        console.log('==========================');
                        
                        displayStats(matchStats);
                        
                        // Load top-rated win separately after initial stats (lazy load)
                        loadTopRatedWin();
                    })
                    .catch(error => {
                        console.error('Error loading match stats:', error);
                    });
                
                // 2b. Load performance vs rating ranges chart
                loadPerformanceChart(chartDaysBack);
                
                // 3. Tournaments (medium speed, show dropdown as soon as ready)
                fetch(`/api/player/${encodeURIComponent(playerName)}/tournaments`)
                    .then(r => r.json())
                    .then(tournamentsData => {
                        if (tournamentsData.error) {
                            console.error('Error loading tournaments:', tournamentsData.error);
                            return;
                        }
                        tournaments = tournamentsData.tournaments || [];
                        populateTournamentDropdown(tournaments);
                    })
                    .catch(error => {
                        console.error('Error loading tournaments:', error);
                    });
                
                // 4. Opponents (load in background, non-blocking)
                loadOpponents();
                
                // 5. Tournament calendar (load in background, non-blocking)
                loadTournamentCalendar();
            } catch (error) {
                showError('Failed to load player data: ' + error.message);
            }
        }
        
        async function loadOpponents() {
            try {
                const response = await fetch(`/api/player/${encodeURIComponent(playerName)}/opponents`);
                const opponents = await response.json();
                
                if (opponents.error) {
                    console.error('Error loading opponents:', opponents.error);
                    return;
                }
                
                // Populate opponent dropdown and auto-select most frequent opponent
                populateOpponentDropdown(opponents.opponents || []);
            } catch (error) {
                console.error('Error loading opponents:', error);
            }
        }
        
        async function loadTopRatedWin() {
            try {
                // Load top-rated win separately (lazy load after initial stats)
                // Always fetch all-time top-rated win (no days_back parameter)
                const response = await fetch(`/api/player/${encodeURIComponent(playerName)}/top-rated-win`);
                const data = await response.json();
                
                if (data.error) {
                    console.error('Error loading top-rated win:', data.error);
                    return;
                }
                
                // Store all-time top-rated win (never changes)
                allTimeTopRatedWin = data.top_rated_win;
                allTimeTopRatedWinInfo = data.top_rated_win_info;
                
                // Update the stats display with top-rated win info
                updateStatsWithTopRatedWin(data.top_rated_win, data.top_rated_win_info);
            } catch (error) {
                console.error('Error loading top-rated win:', error);
            }
        }
        
        function updateStatsWithTopRatedWin(topRatedWin, topRatedWinInfo) {
            // Find the top-rated win stat card and update it
            const statsCards = document.getElementById('statsCards');
            if (!statsCards) return;
            
            // Find the top-rated win card by searching for the label text
            const cards = statsCards.querySelectorAll('.stat-card');
            let topRatedWinCard = null;
            for (const card of cards) {
                const labelDiv = card.querySelector('.label');
                if (labelDiv && labelDiv.textContent.trim() === 'Top Rated Win') {
                    topRatedWinCard = card;
                    break;
                }
            }
            
            if (topRatedWinCard) {
                const valueDiv = topRatedWinCard.querySelector('.value');
                const labelDiv = topRatedWinCard.querySelector('.label');
                
                if (valueDiv && labelDiv) {
                    valueDiv.textContent = (topRatedWin !== null && topRatedWin !== undefined && topRatedWin !== '') ? topRatedWin : 'N/A';
                    valueDiv.className = topRatedWinInfo ? 'value extra-small' : 'value';
                    
                    // Update sub-info if available
                    let subInfo = topRatedWinCard.querySelectorAll('.sub-info');
                    subInfo.forEach(el => el.remove());
                    
                    if (topRatedWinInfo) {
                        const subInfo1 = document.createElement('div');
                        subInfo1.className = 'sub-info';
                        subInfo1.innerHTML = createPlayerLink(topRatedWinInfo.opponent_name || 'Unknown');
                        topRatedWinCard.appendChild(subInfo1);
                        
                        const subInfo2 = document.createElement('div');
                        subInfo2.className = 'sub-info';
                        subInfo2.textContent = formatDate(topRatedWinInfo.date);
                        topRatedWinCard.appendChild(subInfo2);
                    }
                }
            }
        }
        
        // Helper function to parse date string as local date (avoid timezone shift)
        function parseLocalDate(dateStr) {
            if (!dateStr) return null;
            try {
                // Parse date string (YYYY-MM-DD) as local date to avoid timezone shift
                const dateParts = dateStr.split('T')[0].split('-');
                if (dateParts.length === 3) {
                    const year = parseInt(dateParts[0]);
                    const month = parseInt(dateParts[1]) - 1; // Month is 0-indexed
                    const day = parseInt(dateParts[2]);
                    return new Date(year, month, day);
                }
            } catch (e) {
                // Fallback to standard parsing if format is different
                return new Date(dateStr);
            }
            return null;
        }
        
        function formatDate(dateStr) {
            if (!dateStr) return 'N/A';
            try {
                const date = parseLocalDate(dateStr);
                if (date && !isNaN(date.getTime())) {
                    return date.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric', 
                        year: 'numeric' 
                    });
                }
            } catch (e) {
                // Keep original if parsing fails
            }
            return dateStr;
        }
        
        let selectedTournamentId = null;
        let tournamentSelectListenerAdded = false;
        
        function populateTournamentDropdown(tournaments) {
            const input = document.getElementById('tournamentSelect');
            const dropdownList = document.getElementById('tournamentDropdownList');
            
            // Store tournaments globally for filtering
            window.allTournaments = tournaments || [];
            
            if (!tournaments || tournaments.length === 0) {
                input.placeholder = 'No tournaments available';
                return;
            }
            
            // Auto-select the first tournament (latest)
            if (tournaments.length > 0) {
                const latestTournament = tournaments[0];
                selectedTournamentId = latestTournament.tournament_id;
                currentTournamentId = latestTournamentId = selectedTournamentId;
                updateTournamentInputDisplay(latestTournament);
                
                // Load matches for the latest tournament
                loadMatches(1);
            } else {
                // No tournaments available
                input.placeholder = 'No tournaments available';
            }
            
            // Add event listeners if not already added
            if (!tournamentSelectListenerAdded) {
                // Input focus - show dropdown with all tournaments
                input.addEventListener('focus', function() {
                    showTournamentDropdown();
                });
                
                // Input typing - filter dropdown
                input.addEventListener('input', function(e) {
                    const filter = e.target.value.toLowerCase();
                    filterTournamentDropdown(filter);
                });
                
                // Click outside to close dropdown
                document.addEventListener('click', function(e) {
                    const dropdown = document.getElementById('tournamentDropdown');
                    if (!dropdown.contains(e.target)) {
                        dropdownList.classList.remove('show');
                        // Restore selected value display
                        if (selectedTournamentId !== null) {
                            const selectedTournament = window.allTournaments.find(t => t.tournament_id === selectedTournamentId);
                            if (selectedTournament) {
                                updateTournamentInputDisplay(selectedTournament);
                            }
                        }
                    }
                });
                
                tournamentSelectListenerAdded = true;
            }
            
            // Don't show dropdown by default - only show on focus
        }
        
        function updateTournamentInputDisplay(tournament) {
            const input = document.getElementById('tournamentSelect');
            if (!tournament) {
                input.value = '';
                return;
            }
            
            const dateStr = tournament.tournament_date || '';
            let formattedDate = dateStr;
            if (dateStr && dateStr !== 'Unknown Date') {
                try {
                    const dateParts = dateStr.split('T')[0].split('-');
                    if (dateParts.length === 3) {
                        const year = parseInt(dateParts[0]);
                        const month = parseInt(dateParts[1]) - 1;
                        const day = parseInt(dateParts[2]);
                        const date = new Date(year, month, day);
                        if (!isNaN(date.getTime())) {
                            formattedDate = date.toLocaleDateString('en-US', { 
                                month: 'short', 
                                day: 'numeric', 
                                year: 'numeric' 
                            });
                        }
                    }
                } catch (e) {
                    formattedDate = dateStr;
                }
            }
            input.value = formattedDate || 'Unknown Date';
        }
        
        function showTournamentDropdown() {
            const dropdownList = document.getElementById('tournamentDropdownList');
            const input = document.getElementById('tournamentSelect');
            
            // Clear dropdown
            dropdownList.innerHTML = '';
            
            // Add tournaments
            const tournaments = window.allTournaments || [];
            tournaments.forEach(tournament => {
                const dateStr = tournament.tournament_date || '';
                let formattedDate = dateStr;
                if (dateStr && dateStr !== 'Unknown Date') {
                    try {
                        const dateParts = dateStr.split('T')[0].split('-');
                        if (dateParts.length === 3) {
                            const year = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1;
                            const day = parseInt(dateParts[2]);
                            const date = new Date(year, month, day);
                            if (!isNaN(date.getTime())) {
                                formattedDate = date.toLocaleDateString('en-US', { 
                                    month: 'short', 
                                    day: 'numeric', 
                                    year: 'numeric' 
                                });
                            }
                        }
                    } catch (e) {
                        formattedDate = dateStr;
                    }
                }
                
                const item = document.createElement('div');
                item.className = 'searchable-dropdown-item';
                if (selectedTournamentId === tournament.tournament_id) {
                    item.classList.add('selected');
                }
                item.textContent = formattedDate || 'Unknown Date';
                item.addEventListener('click', function() {
                    selectedTournamentId = tournament.tournament_id;
                    currentTournamentId = tournament.tournament_id;
                    updateTournamentInputDisplay(tournament);
                    dropdownList.classList.remove('show');
                    loadMatches(1);
                });
                dropdownList.appendChild(item);
            });
            
            // Show dropdown
            dropdownList.classList.add('show');
        }
        
        function filterTournamentDropdown(filter) {
            const dropdownList = document.getElementById('tournamentDropdownList');
            const input = document.getElementById('tournamentSelect');
            
            // Clear dropdown
            dropdownList.innerHTML = '';
            
            if (filter === '') {
                showTournamentDropdown();
                return;
            }
            
            // Filter tournaments
            const tournaments = window.allTournaments || [];
            const filtered = tournaments.filter(t => {
                const dateStr = t.tournament_date || '';
                let formattedDate = dateStr;
                if (dateStr && dateStr !== 'Unknown Date') {
                    try {
                        const dateParts = dateStr.split('T')[0].split('-');
                        if (dateParts.length === 3) {
                            const year = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1;
                            const day = parseInt(dateParts[2]);
                            const date = new Date(year, month, day);
                            if (!isNaN(date.getTime())) {
                                formattedDate = date.toLocaleDateString('en-US', { 
                                    month: 'short', 
                                    day: 'numeric', 
                                    year: 'numeric' 
                                });
                            }
                        }
                    } catch (e) {
                        formattedDate = dateStr;
                    }
                }
                return formattedDate.toLowerCase().includes(filter);
            });
            
            if (filtered.length === 0) {
                const noResults = document.createElement('div');
                noResults.className = 'searchable-dropdown-item no-results';
                noResults.textContent = 'No tournaments found';
                dropdownList.appendChild(noResults);
            } else {
                // Add filtered tournaments
                filtered.forEach(tournament => {
                    const dateStr = tournament.tournament_date || '';
                    let formattedDate = dateStr;
                    if (dateStr && dateStr !== 'Unknown Date') {
                        try {
                            const dateParts = dateStr.split('T')[0].split('-');
                            if (dateParts.length === 3) {
                                const year = parseInt(dateParts[0]);
                                const month = parseInt(dateParts[1]) - 1;
                                const day = parseInt(dateParts[2]);
                                const date = new Date(year, month, day);
                                if (!isNaN(date.getTime())) {
                                    formattedDate = date.toLocaleDateString('en-US', { 
                                        month: 'short', 
                                        day: 'numeric', 
                                        year: 'numeric' 
                                    });
                                }
                            }
                        } catch (e) {
                            formattedDate = dateStr;
                        }
                    }
                    
                    const item = document.createElement('div');
                    item.className = 'searchable-dropdown-item';
                    if (selectedTournamentId === tournament.tournament_id) {
                        item.classList.add('selected');
                    }
                    item.textContent = formattedDate || 'Unknown Date';
                    item.addEventListener('click', function() {
                        selectedTournamentId = tournament.tournament_id;
                        currentTournamentId = tournament.tournament_id;
                        updateTournamentInputDisplay(tournament);
                        dropdownList.classList.remove('show');
                        loadMatches(1);
                    });
                    dropdownList.appendChild(item);
                });
            }
            
            // Show dropdown
            dropdownList.classList.add('show');
        }
        
        function populateOpponentDropdown(opponents) {
            const input = document.getElementById('opponentSelect');
            const dropdownList = document.getElementById('opponentDropdownList');
            
            // Store all opponents
            allOpponents = opponents || [];
            
            if (!allOpponents || allOpponents.length === 0) {
                input.placeholder = '-- No opponents found --';
                input.readOnly = true;
                dropdownList.innerHTML = '';
                return;
            }
            
            // Make input editable for searching
            input.readOnly = false;
            input.placeholder = 'Type to search opponents...';
            
            // Auto-select the first opponent (most frequent)
            const firstOpponent = allOpponents[0].name || allOpponents[0];
            selectedOpponent = firstOpponent;
            updateOpponentInputDisplay(firstOpponent);
            
            // Load head-to-head matches for the most frequent opponent
            loadHeadToHeadMatches(firstOpponent);
            
            // Add event listeners (only once)
            if (!opponentSelectListenerAdded) {
                // Input focus - show dropdown with all opponents
                input.addEventListener('focus', function() {
                    // Clear the input to show all opponents by default
                    this.value = '';
                    highlightedIndex = -1;
                    filterAndShowOpponents('');
                });
                
                // Input typing - filter dropdown
                input.addEventListener('input', function() {
                    highlightedIndex = -1;
                    filterAndShowOpponents(this.value);
                });
                
                // Keyboard navigation
                input.addEventListener('keydown', function(e) {
                    const dropdownList = document.getElementById('opponentDropdownList');
                    if (!dropdownList.classList.contains('show')) {
                        return;
                    }
                    
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        highlightedIndex = Math.min(highlightedIndex + 1, filteredOpponents.length - 1);
                        updateHighlightedItem();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        highlightedIndex = Math.max(highlightedIndex - 1, -1);
                        updateHighlightedItem();
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        if (highlightedIndex >= 0 && highlightedIndex < filteredOpponents.length) {
                            const opponent = filteredOpponents[highlightedIndex];
                            const opponentName = opponent.name || opponent;
                            selectedOpponent = opponentName;
                            updateOpponentInputDisplay(opponentName);
                            dropdownList.classList.remove('show');
                            loadHeadToHeadMatches(opponentName, 1);
                        }
                    } else if (e.key === 'Escape') {
                        dropdownList.classList.remove('show');
                        if (selectedOpponent) {
                            updateOpponentInputDisplay(selectedOpponent);
                        }
                    }
                });
                
                // Click outside to close dropdown
                document.addEventListener('click', function(e) {
                    const dropdown = document.getElementById('opponentDropdown');
                    if (!dropdown.contains(e.target)) {
                        dropdownList.classList.remove('show');
                        // Restore selected value display
                        if (selectedOpponent) {
                            updateOpponentInputDisplay(selectedOpponent);
                        }
                    }
                });
                
                opponentSelectListenerAdded = true;
            }
            
            // Initial display of all opponents (but don't show dropdown yet)
            // Dropdown will show when user focuses on input
        }
        
        function updateOpponentInputDisplay(opponentName) {
            const input = document.getElementById('opponentSelect');
            const opponent = allOpponents.find(o => (o.name || o) === opponentName);
            if (opponent) {
                const matchCount = opponent.match_count || 0;
                input.value = `${opponentName} (${matchCount} match${matchCount !== 1 ? 'es' : ''})`;
            } else {
                input.value = opponentName;
            }
        }
        
        function filterAndShowOpponents(searchTerm) {
            const dropdownList = document.getElementById('opponentDropdownList');
            const input = document.getElementById('opponentSelect');
            
            // Extract just the name part from search term (remove match count if present)
            // Format: "Name (X matches)" -> extract "Name"
            let searchLower = searchTerm.toLowerCase().trim();
            const matchCountMatch = searchLower.match(/^(.+?)\s*\(\d+\s*match/i);
            if (matchCountMatch) {
                searchLower = matchCountMatch[1].trim();
            }
            
            // Filter opponents based on search term
            filteredOpponents = allOpponents.filter(opponent => {
                const opponentName = (opponent.name || opponent).toLowerCase();
                return opponentName.includes(searchLower);
            });
            
            // Clear dropdown
            dropdownList.innerHTML = '';
            
            if (filteredOpponents.length === 0) {
                const noResults = document.createElement('div');
                noResults.className = 'searchable-dropdown-item no-results';
                noResults.textContent = 'No opponents found';
                dropdownList.appendChild(noResults);
            } else {
                // Add filtered opponents to dropdown
                filteredOpponents.forEach((opponent, index) => {
                    const opponentName = opponent.name || opponent;
                    const matchCount = opponent.match_count || 0;
                    const item = document.createElement('div');
                    item.className = 'searchable-dropdown-item';
                    item.setAttribute('data-index', index);
                    if (selectedOpponent === opponentName) {
                        item.classList.add('selected');
                    }
                    item.textContent = `${opponentName} (${matchCount} match${matchCount !== 1 ? 'es' : ''})`;
                    item.addEventListener('click', function() {
                        selectedOpponent = opponentName;
                        updateOpponentInputDisplay(opponentName);
                        dropdownList.classList.remove('show');
                        loadHeadToHeadMatches(opponentName);
                    });
                    dropdownList.appendChild(item);
                });
            }
            
            // Show dropdown
            dropdownList.classList.add('show');
            updateHighlightedItem();
        }
        
        function updateHighlightedItem() {
            const items = document.querySelectorAll('.searchable-dropdown-item[data-index]');
            if (items.length === 0) {
                return;
            }
            items.forEach((item, index) => {
                if (index === highlightedIndex) {
                    item.style.background = '#7c9eff';
                    item.style.color = '#1a1a1a';
                    // Scroll into view if needed
                    item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                } else {
                    item.style.background = '';
                    item.style.color = '';
                }
            });
        }
        
        async function loadHeadToHeadMatches(opponentName, page = 1) {
            try {
                // Reset to page 1 when opponent changes
                if (page === 1) {
                    h2hCurrentPage = 1;
                }
                
                const response = await fetch(`/api/player/${encodeURIComponent(playerName)}/vs/${encodeURIComponent(opponentName)}?page=${page}&page_size=${h2hPageSize}`);
                const data = await response.json();
                
                if (data.error) {
                    showError(data.error);
                    return;
                }
                
                // Update pagination state
                h2hTotalMatches = data.total || 0;
                h2hTotalPages = data.total_pages || 0;
                h2hCurrentPage = data.page || page;
                
                displayHeadToHeadMatches(data.matches || [], opponentName, data);
            } catch (error) {
                console.error('Error loading head-to-head matches:', error);
                showError('Failed to load head-to-head matches: ' + error.message);
            }
        }
        
        function goToH2HPage(page) {
            if (page >= 1 && page <= h2hTotalPages && selectedOpponent) {
                loadHeadToHeadMatches(selectedOpponent, page);
            }
        }
        
        function displayHeadToHeadMatches(matches, opponentName, paginationData = null) {
            const tableDiv = document.getElementById('headToHeadTable');
            
            if (!matches || matches.length === 0) {
                tableDiv.innerHTML = '<div class="no-data">No matches found between ' + escapeHtml(playerName) + ' and ' + createPlayerLink(opponentName) + '</div>';
                // Hide pagination if no matches
                document.getElementById('h2hPagination').style.display = 'none';
                return;
            }
            
            // Get total head-to-head statistics from pagination data
            let playerWins = 0;
            let opponentWins = 0;
            
            if (paginationData) {
                // Determine which player is player1 and which is player2 in the API response
                // The API returns player1_wins and player2_wins where player1_name is the first player in the URL
                if (paginationData.player1_name === playerName) {
                    // Our player is player1 in the API response
                    playerWins = paginationData.player1_wins || 0;
                    opponentWins = paginationData.player2_wins || 0;
                } else if (paginationData.player2_name === playerName) {
                    // Our player is player2 in the API response, swap the wins
                    playerWins = paginationData.player2_wins || 0;
                    opponentWins = paginationData.player1_wins || 0;
                } else {
                    // Fallback: assume player1 is our player if names don't match
                    playerWins = paginationData.player1_wins || 0;
                    opponentWins = paginationData.player2_wins || 0;
                }
            }
            
            // Display statistics
            let html = `
                <div class="head-to-head-stats">
                    <div class="h2h-stat h2h-stat-win">
                        <div class="value">${playerWins}</div>
                        <div class="label">${escapeHtml(playerName)} Wins</div>
                    </div>
                    <div class="h2h-stat h2h-stat-loss">
                        <div class="value">${opponentWins}</div>
                        <div class="label">${createPlayerLink(opponentName)} Wins</div>
                    </div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>${escapeHtml(playerName)}</th>
                            <th>Rating</th>
                            <th>Score</th>
                            <th>Rating</th>
                            <th>${createPlayerLink(opponentName)}</th>
                            <th>Result</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            matches.forEach(match => {
                const isPlayer1 = match.player1_name === playerName;
                const playerScore = isPlayer1 ? match.player1_score : match.player2_score;
                const opponentScore = isPlayer1 ? match.player2_score : match.player1_score;
                const playerRating = isPlayer1 ? match.player1_rating : match.player2_rating;
                const opponentRating = isPlayer1 ? match.player2_rating : match.player1_rating;
                
                // Determine winner
                let resultClass = '';
                let resultText = 'Draw';
                if (match.winner_name === playerName) {
                    resultClass = 'win';
                    resultText = 'Win';
                } else if (match.winner_name === opponentName) {
                    resultClass = 'loss';
                    resultText = 'Loss';
                }
                
                // Format date
                let dateStr = match.tournament_date || 'N/A';
                let dateDisplay = dateStr;
                if (dateStr !== 'N/A' && dateStr) {
                    try {
                        const date = parseLocalDate(dateStr);
                        if (date && !isNaN(date.getTime())) {
                            dateDisplay = date.toLocaleDateString('en-US', { 
                                month: 'short', 
                                day: 'numeric', 
                                year: 'numeric' 
                            });
                        }
                    } catch (e) {
                        // Keep original if parsing fails
                    }
                }
                
                // Make date a link to tournament if tournament_id is available
                const tournamentId = match.tournament_id;
                const dateCell = tournamentId 
                    ? `<a href="/tournament/${tournamentId}" class="tournament-date-link">${dateDisplay}</a>`
                    : dateDisplay;
                
                // Format ratings
                const playerRatingStr = playerRating !== null && playerRating !== undefined ? playerRating.toString() : 'N/A';
                const opponentRatingStr = opponentRating !== null && opponentRating !== undefined ? opponentRating.toString() : 'N/A';
                
                html += `
                    <tr>
                        <td>${dateCell}</td>
                        <td>${escapeHtml(playerName)}</td>
                        <td>${playerRatingStr}</td>
                        <td>${playerScore || 0}-${opponentScore || 0}</td>
                        <td>${opponentRatingStr}</td>
                        <td>${createPlayerLink(opponentName)}</td>
                        <td class="${resultClass}">${resultText}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            tableDiv.innerHTML = html;
            
            // Display pagination if data provided
            if (paginationData) {
                displayH2HPagination(paginationData);
            }
        }
        
        function displayH2HPagination(data) {
            const paginationDiv = document.getElementById('h2hPagination');
            
            if (!data || data.total === 0 || data.total_pages <= 1) {
                paginationDiv.style.display = 'none';
                return;
            }
            
            paginationDiv.style.display = 'flex';
            
            const page = data.page || 1;
            const total = data.total || 0;
            const totalPages = data.total_pages || 0;
            const pageSize = data.page_size || 20;
            
            const start = (page - 1) * pageSize + 1;
            const end = Math.min(page * pageSize, total);
            
            // Calculate page numbers to show
            const maxPagesToShow = 7;
            let startPage = Math.max(1, page - Math.floor(maxPagesToShow / 2));
            let endPage = Math.min(totalPages, startPage + maxPagesToShow - 1);
            
            if (endPage - startPage < maxPagesToShow - 1) {
                startPage = Math.max(1, endPage - maxPagesToShow + 1);
            }
            
            let html = `
                <div class="pagination-info">
                    Showing ${start}-${end} of ${total} matches
                </div>
                <div class="pagination-controls">
                    <button class="pagination-btn" onclick="goToH2HPage(${page - 1})" ${page === 1 ? 'disabled' : ''}>
                        Previous
                    </button>
                    <div class="page-numbers">
            `;
            
            // First page
            if (startPage > 1) {
                html += `<span class="page-number ${1 === page ? 'active' : ''}" onclick="goToH2HPage(1)">1</span>`;
                if (startPage > 2) {
                    html += `<span class="page-number" style="cursor: default; border: none;">...</span>`;
                }
            }
            
            // Page numbers
            for (let i = startPage; i <= endPage; i++) {
                html += `<span class="page-number ${i === page ? 'active' : ''}" onclick="goToH2HPage(${i})">${i}</span>`;
            }
            
            // Last page
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    html += `<span class="page-number" style="cursor: default; border: none;">...</span>`;
                }
                html += `<span class="page-number ${totalPages === page ? 'active' : ''}" onclick="goToH2HPage(${totalPages})">${totalPages}</span>`;
            }
            
            html += `
                    </div>
                    <button class="pagination-btn" onclick="goToH2HPage(${page + 1})" ${page === totalPages ? 'disabled' : ''}>
                        Next
                    </button>
                </div>
            `;
            
            paginationDiv.innerHTML = html;
        }
        
        async function loadMatches(page = 1) {
            // Update state
            currentPage = page;
            
            try {
                let url = `/api/player/${encodeURIComponent(playerName)}/matches?page=${page}&page_size=${pageSize}`;
                
                // Add tournament filter if selected
                if (currentTournamentId !== null && currentTournamentId !== undefined) {
                    url += `&tournament_id=${currentTournamentId}`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                console.log('Matches API response:', data);
                
                if (data.error) {
                    console.error('Matches API error:', data.error);
                    showError(data.error);
                    return;
                }
                
                // Update pagination state
                totalMatches = data.total || 0;
                totalPages = data.total_pages || 0;
                currentPage = data.page || page;
                
                const matches = data.matches || [];
                console.log(`Found ${matches.length} matches (page ${currentPage} of ${totalPages})`);
                
                displayMatches(matches);
                displayPagination(data);
            } catch (error) {
                console.error('Error loading matches:', error);
                showError('Failed to load matches: ' + error.message);
            }
        }
        
        function goToPage(page) {
            if (page >= 1 && page <= totalPages) {
                loadMatches(page);
            }
        }
        
        async function updateChart(daysBack) {
            // Update active button
            document.querySelectorAll('.timeline-selector .timeline-btn').forEach(btn => {
                btn.classList.remove('active');
                const btnDays = btn.getAttribute('data-days');
                if ((daysBack === null && btnDays === 'null') || 
                    (daysBack !== null && btnDays === String(daysBack))) {
                    btn.classList.add('active');
                }
            });
            
            // Update chart filter
            chartDaysBack = daysBack;
            
            // Re-render chart with filtered data
            if (allRatingData) {
                displayRatingChart(allRatingData, daysBack);
            }
            
            // Update stats based on timespan
            await updateStats(daysBack);
            
            // Update performance chart with new filter
            loadPerformanceChart(daysBack);
        }
        
        async function loadPerformanceChart(daysBack = null) {
            try {
                let url = `/api/player/${encodeURIComponent(playerName)}/performance-vs-rating-ranges`;
                if (daysBack !== null && daysBack !== undefined) {
                    url += `?days_back=${daysBack}`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.error) {
                    console.error('Error loading performance chart:', data.error);
                    return;
                }
                
                displayPerformanceChart(data);
            } catch (error) {
                console.error('Error loading performance chart:', error);
            }
        }
        
        function displayPerformanceChart(data) {
            const ctx = document.getElementById('performanceChart').getContext('2d');
            
            if (performanceChart) {
                performanceChart.destroy();
            }
            
            // Map range keys to display labels
            const rangeLabels = {
                '100_plus_higher': '100+ Points Higher',
                '50_100_higher': '50-100 Points Higher',
                'similar': 'Similar Rating (±50)',
                '50_100_lower': '50-100 Points Lower',
                '100_plus_lower': '100+ Points Lower'
            };
            
            // Order ranges from lowest to highest opponent rating
            const rangeOrder = ['100_plus_lower', '50_100_lower', 'similar', '50_100_higher', '100_plus_higher'];
            
            const labels = rangeOrder.map(key => rangeLabels[key]);
            const winRates = rangeOrder.map(key => data[key]?.win_rate || 0);
            const totals = rangeOrder.map(key => data[key]?.total || 0);
            
            // Check if we have any data
            const hasData = totals.some(total => total > 0);
            
            if (!hasData) {
                document.getElementById('performanceChart').parentElement.innerHTML = 
                    '<div class="no-data">No match data available for performance analysis</div>';
                return;
            }
            
            performanceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Win Rate (%)',
                        data: winRates,
                        backgroundColor: winRates.map(rate => {
                            if (rate >= 60) return '#28a745'; // Green for good performance
                            if (rate >= 40) return '#ffc107'; // Yellow for moderate
                            return '#dc3545'; // Red for poor performance
                        }),
                        borderColor: '#607890',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const rangeKey = rangeOrder[index];
                                    const stats = data[rangeKey];
                                    return [
                                        `Win Rate: ${stats.win_rate}%`,
                                        `Wins: ${stats.wins}`,
                                        `Total Matches: ${stats.total}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Win Rate (%)',
                                color: '#444',
                                font: {
                                    family: "'PT Sans Narrow', sans-serif",
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                color: '#444',
                                callback: function(value) {
                                    return value + '%';
                                }
                            },
                            grid: {
                                color: '#dee2e6'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Opponent Rating Range',
                                color: '#444',
                                font: {
                                    family: "'PT Sans Narrow', sans-serif",
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                color: '#444',
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }
        
        async function updateStats(daysBack) {
            try {
                let url = `/api/player/${encodeURIComponent(playerName)}/match-stats`;
                if (daysBack !== null && daysBack !== undefined) {
                    url += `?days_back=${daysBack}`;
                }
                
                const response = await fetch(url);
                const stats = await response.json();
                
                if (stats.error) {
                    console.error('Error loading stats:', stats.error);
                    return;
                }
                
                // Debug: log the stats to see what we're getting
                console.log('=== STATS DEBUG ===');
                console.log('Full stats object:', JSON.stringify(stats, null, 2));
                console.log('Highest rating:', stats.highest_rating, 'Type:', typeof stats.highest_rating);
                console.log('Top rated win:', stats.top_rated_win, 'Type:', typeof stats.top_rated_win);
                console.log('Date joined:', stats.date_joined, 'Type:', typeof stats.date_joined);
                console.log('Last match date:', stats.last_match_date, 'Type:', typeof stats.last_match_date);
                if (stats._debug) {
                    console.log('Debug info:', stats._debug);
                }
                console.log('==================');
                
                displayStats(stats);
            } catch (error) {
                console.error('Error updating stats:', error);
            }
        }
        
        function displayPagination(data) {
            const paginationDiv = document.getElementById('pagination');
            
            if (!data || data.total === 0 || data.total_pages <= 1) {
                paginationDiv.style.display = 'none';
                return;
            }
            
            paginationDiv.style.display = 'flex';
            
            const page = data.page || 1;
            const total = data.total || 0;
            const totalPages = data.total_pages || 0;
            const pageSize = data.page_size || 20;
            
            const start = (page - 1) * pageSize + 1;
            const end = Math.min(page * pageSize, total);
            
            // Calculate page numbers to show
            const maxPagesToShow = 7;
            let startPage = Math.max(1, page - Math.floor(maxPagesToShow / 2));
            let endPage = Math.min(totalPages, startPage + maxPagesToShow - 1);
            
            if (endPage - startPage < maxPagesToShow - 1) {
                startPage = Math.max(1, endPage - maxPagesToShow + 1);
            }
            
            let html = `
                <div class="pagination-info">
                    Showing ${start}-${end} of ${total} matches
                </div>
                <div class="pagination-controls">
                    <button class="pagination-btn" onclick="goToPage(${page - 1})" ${page === 1 ? 'disabled' : ''}>
                        Previous
                    </button>
                    <div class="page-numbers">
            `;
            
            // First page
            if (startPage > 1) {
                html += `<span class="page-number ${1 === page ? 'active' : ''}" onclick="goToPage(1)">1</span>`;
                if (startPage > 2) {
                    html += `<span class="page-number" style="cursor: default; border: none;">...</span>`;
                }
            }
            
            // Page numbers
            for (let i = startPage; i <= endPage; i++) {
                html += `<span class="page-number ${i === page ? 'active' : ''}" onclick="goToPage(${i})">${i}</span>`;
            }
            
            // Last page
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    html += `<span class="page-number" style="cursor: default; border: none;">...</span>`;
                }
                html += `<span class="page-number ${totalPages === page ? 'active' : ''}" onclick="goToPage(${totalPages})">${totalPages}</span>`;
            }
            
            html += `
                    </div>
                    <button class="pagination-btn" onclick="goToPage(${page + 1})" ${page === totalPages ? 'disabled' : ''}>
                        Next
                    </button>
                </div>
            `;
            
            paginationDiv.innerHTML = html;
        }
        
        function displayStats(stats) {
            const cards = document.getElementById('statsCards');
            
            // Debug: log what we're displaying
            console.log('displayStats called with:', stats);
            console.log('highest_rating:', stats.highest_rating);
            console.log('top_rated_win:', stats.top_rated_win);
            console.log('date_joined:', stats.date_joined);
            console.log('last_match_date:', stats.last_match_date);
            
            // Format date helper (uses parseLocalDate to avoid timezone issues)
            function formatDate(dateStr) {
                if (!dateStr) return 'N/A';
                try {
                    const date = parseLocalDate(dateStr);
                    if (date && !isNaN(date.getTime())) {
                        return date.toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric', 
                            year: 'numeric' 
                        });
                    }
                } catch (e) {
                    // Keep original if parsing fails
                }
                return dateStr;
            }
            
            // Get current rating from rating history (latest rating_post, fallback to rating_pre)
            let currentRating = 'N/A';
            if (allRatingData && allRatingData.raw_data && allRatingData.raw_data.length > 0) {
                const rawData = allRatingData.raw_data;
                // Sort by date descending to get the most recent
                const sortedData = [...rawData].sort((a, b) => {
                    const dateA = parseLocalDate(a.tournament_date || a.date);
                    const dateB = parseLocalDate(b.tournament_date || b.date);
                    if (!dateA || !dateB) return 0;
                    return dateB - dateA;
                });
                // Get the most recent rating_post, fallback to rating_pre if rating_post is missing
                for (const entry of sortedData) {
                    if (entry.rating_post !== null && entry.rating_post !== undefined && entry.rating_post !== '') {
                        currentRating = entry.rating_post;
                        break;
                    } else if (entry.rating_pre !== null && entry.rating_pre !== undefined && entry.rating_pre !== '') {
                        // Fallback to rating_pre if rating_post is missing
                        currentRating = entry.rating_pre;
                        break;
                    }
                }
            }
            
            // Find highest rating date from rating history
            let highestRatingDate = null;
            if (stats.highest_rating !== null && stats.highest_rating !== undefined && stats.highest_rating !== '' && allRatingData && allRatingData.raw_data) {
                const rawData = allRatingData.raw_data;
                // Find the entry where rating_post equals highest_rating
                for (const entry of rawData) {
                    if (entry.rating_post !== null && entry.rating_post !== undefined && entry.rating_post !== '') {
                        try {
                            const ratingVal = parseInt(entry.rating_post);
                            if (ratingVal === parseInt(stats.highest_rating)) {
                                highestRatingDate = entry.tournament_date || entry.date;
                                break;
                            }
                        } catch (e) {
                            // Skip invalid ratings
                        }
                    }
                }
            }
            
            // Always use all-time top-rated win if available, otherwise use stats value
            const topRatedWinToDisplay = allTimeTopRatedWin !== null ? allTimeTopRatedWin : stats.top_rated_win;
            const topRatedWinInfoToDisplay = allTimeTopRatedWinInfo !== null ? allTimeTopRatedWinInfo : stats.top_rated_win_info;
            
            cards.innerHTML = `
                <div class="stats-row row-1">
                    <div class="stat-card current-rating">
                        <div class="value">${currentRating}</div>
                        <div class="label">Current Rating</div>
                    </div>
                    <div class="stat-card highest-rating">
                        <div class="value">${(stats.highest_rating !== null && stats.highest_rating !== undefined && stats.highest_rating !== '') ? stats.highest_rating : 'N/A'}</div>
                        <div class="label">Highest Rating</div>
                        ${highestRatingDate ? `
                            <div class="sub-info">${formatDate(highestRatingDate)}</div>
                        ` : ''}
                    </div>
                    <div class="stat-card">
                        <div class="value">${(stats.ranking !== null && stats.ranking !== undefined) ? `#${stats.ranking}` : 'N/A'}</div>
                        <div class="label">Rank</div>
                        ${(stats.players_better_than !== null && stats.players_better_than !== undefined && stats.total_players !== null && stats.total_players !== undefined && stats.total_players > 0) ? `
                            <div class="sub-info" style="margin-top: 8px; font-size: 0.95em; color: #666;">
                                Top ${(100 - ((stats.players_better_than / stats.total_players) * 100)).toFixed(2)}%
                            </div>
                        ` : ''}
                    </div>
                    <div class="stat-card">
                        <div class="value ${topRatedWinInfoToDisplay ? 'extra-small' : ''}">${(topRatedWinToDisplay !== null && topRatedWinToDisplay !== undefined && topRatedWinToDisplay !== '') ? topRatedWinToDisplay : 'N/A'}</div>
                        <div class="label">Top Rated Win</div>
                        ${topRatedWinInfoToDisplay ? `
                            <div class="sub-info">${createPlayerLink(topRatedWinInfoToDisplay.opponent_name || 'Unknown')}</div>
                            <div class="sub-info">${formatDate(topRatedWinInfoToDisplay.date)}</div>
                        ` : ''}
                    </div>
                </div>
                <div class="stats-row row-2">
                    <div class="stat-card">
                        <div class="value">${stats.total_tournaments || 0}</div>
                        <div class="label">Total Tournaments Attended</div>
                    </div>
                    <div class="stat-card wins">
                        <div class="value">${stats.wins || 0}</div>
                        <div class="label">Wins</div>
                    </div>
                    <div class="stat-card losses">
                        <div class="value">${stats.losses || 0}</div>
                        <div class="label">Losses</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${(stats.win_percentage || 0).toFixed(1)}%</div>
                        <div class="label">Win Percentage</div>
                    </div>
                </div>
                <div class="stats-row row-3">
                    <div class="stat-card">
                        <div class="value small">${formatDate(stats.date_joined)}</div>
                        <div class="label">Date Joined</div>
                    </div>
                    <div class="stat-card">
                        <div class="value small">${formatDate(stats.last_match_date)}</div>
                        <div class="label">Last Match</div>
                    </div>
                </div>
            `;
        }
        
        function displayRatingChart(data, daysBack = null) {
            const ctx = document.getElementById('ratingChart').getContext('2d');
            
            if (!data.chart_data || !data.chart_data.labels || data.chart_data.labels.length === 0) {
                document.getElementById('ratingChart').parentElement.innerHTML = 
                    '<div class="no-data">No rating history available</div>';
                return;
            }
            
            if (ratingChart) {
                ratingChart.destroy();
            }
            
            // Create continuous time axis using time scale
            const rawData = data.raw_data || [];
            if (rawData.length === 0) {
                document.getElementById('ratingChart').parentElement.innerHTML = 
                    '<div class="no-data">No rating history available</div>';
                return;
            }
            
            // Filter by date if daysBack is provided
            let filteredData = rawData;
            if (daysBack !== null && daysBack !== undefined) {
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - daysBack);
                filteredData = rawData.filter(entry => {
                    const dateStr = entry.tournament_date || entry.date;
                    if (!dateStr) return false;
                    const entryDate = parseLocalDate(dateStr);
                    if (!entryDate) return false;
                    return entryDate >= cutoffDate;
                });
            }
            
            if (filteredData.length === 0) {
                document.getElementById('ratingChart').parentElement.innerHTML = 
                    '<div class="no-data">No rating history available for selected time period</div>';
                return;
            }
            
            // Parse dates and ratings, converting rating_post to number
            const chartData = filteredData.map(entry => {
                const dateStr = entry.tournament_date || entry.date;
                if (!dateStr) return null;
                const date = parseLocalDate(dateStr);
                if (!date) return null;
                
                // Convert rating_post to number (handle string values)
                let rating = entry.rating_post;
                if (rating === null || rating === undefined || rating === '') {
                    return null;
                }
                
                // Convert to number if it's a string
                if (typeof rating === 'string') {
                    rating = parseFloat(rating);
                    if (isNaN(rating)) {
                        return null;
                    }
                }
                
                return {
                    x: date,
                    y: rating,
                    dateStr: dateStr, // Keep original date string for deduplication
                    entry: entry // Keep full entry for reference
                };
            }).filter(d => d !== null && d.y !== null && d.y !== undefined && !isNaN(d.y));
            
            if (chartData.length === 0) {
                document.getElementById('ratingChart').parentElement.innerHTML = 
                    '<div class="no-data">No rating history available</div>';
                return;
            }
            
            // Sort by date
            chartData.sort((a, b) => a.x - b.x);
            
            // Deduplicate: if multiple entries for the same date, keep the one with the latest rating_post
            // This handles cases where reimporting might have created duplicate entries
            const deduplicatedData = [];
            const dateMap = new Map();
            
            for (const point of chartData) {
                const dateKey = point.dateStr || point.x.getTime().toString();
                const existing = dateMap.get(dateKey);
                
                if (!existing) {
                    dateMap.set(dateKey, point);
                    deduplicatedData.push(point);
                } else {
                    // If same date, keep the one with higher rating_post (more recent data)
                    if (point.y > existing.y) {
                        const index = deduplicatedData.indexOf(existing);
                        deduplicatedData[index] = point;
                        dateMap.set(dateKey, point);
                    }
                }
            }
            
            // Use deduplicated data
            const finalChartData = deduplicatedData.map(d => ({
                x: d.x,
                y: d.y
            }));
            
            // Calculate rating change in the selected timeframe
            let ratingChange = 0;
            let ratingChangeText = '';
            const ratingChangeIndicator = document.getElementById('ratingChangeIndicator');
            
            if (finalChartData.length > 0) {
                // Get first and last rating in the sorted chart data (chronologically)
                const firstRating = finalChartData[0].y;
                const lastRating = finalChartData[finalChartData.length - 1].y;
                
                if (firstRating !== null && firstRating !== undefined && 
                    lastRating !== null && lastRating !== undefined) {
                    ratingChange = lastRating - firstRating;
                    
                    if (ratingChange > 0) {
                        ratingChangeText = `<span style="color: #28a745;">+${ratingChange} points</span>`;
                    } else if (ratingChange < 0) {
                        ratingChangeText = `<span style="color: #dc3545;">${ratingChange} points</span>`;
                    } else {
                        ratingChangeText = `<span style="color: #b0b0b0;">0 points</span>`;
                    }
                }
            }
            
            // Display rating change indicator
            if (ratingChangeIndicator) {
                ratingChangeIndicator.innerHTML = ratingChangeText || '';
            }
            
            // Get min and max dates for axis bounds
            const dates = finalChartData.map(d => d.x);
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));
            
            // Add small padding for cleaner appearance (about 2% of date range)
            const dateRange = maxDate - minDate;
            const padding = dateRange * 0.02; // 2% padding
            const minDateWithPadding = new Date(minDate.getTime() - padding);
            const maxDateWithPadding = new Date(maxDate.getTime() + padding);
            
            ratingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Rating',
                        data: finalChartData,
                        borderColor: '#607890',
                        backgroundColor: 'rgba(96, 120, 144, 0.2)',
                        tension: 0.1,
                        fill: true,
                        spanGaps: false,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: '#607890',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x',
                                modifierKey: null
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                    modifierKey: 'ctrl'
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x',
                                drag: {
                                    enabled: true,
                                    modifierKey: null,
                                    backgroundColor: 'rgba(96, 120, 144, 0.1)',
                                    borderColor: 'rgba(96, 120, 144, 0.3)',
                                    borderWidth: 1
                                }
                            },
                            limits: {
                                x: {
                                    min: minDateWithPadding.getTime(),
                                    max: maxDateWithPadding.getTime()
                                }
                            }
                        },
                        tooltip: {
                            enabled: false,
                            external: function(context) {
                                const {chart, tooltip} = context;
                                let tooltipEl = document.getElementById('chartTooltip');
                                
                                if (!tooltipEl) {
                                    tooltipEl = document.createElement('div');
                                    tooltipEl.id = 'chartTooltip';
                                    tooltipEl.style.cssText = 'position: fixed; background: #fff; border: 1px solid #607890; border-radius: 4px; padding: 8px 12px; pointer-events: none; opacity: 0; z-index: 1000; box-shadow: 0 2px 8px rgba(0,0,0,0.15); font-family: "PT Sans Narrow", sans-serif; transform: translate(-50%, -100%);';
                                    document.body.appendChild(tooltipEl);
                                }
                                
                                if (tooltip.opacity === 0) {
                                    tooltipEl.style.opacity = '0';
                                    return;
                                }
                                
                                const dataPoint = tooltip.dataPoints[0];
                                if (!dataPoint) {
                                    tooltipEl.style.opacity = '0';
                                    return;
                                }
                                
                                const value = dataPoint.parsed.y;
                                const index = dataPoint.dataIndex;
                                const date = new Date(dataPoint.parsed.x);
                                
                                // Calculate change from previous point
                                let changeHtml = '';
                                if (index > 0 && finalChartData[index - 1]) {
                                    const previousValue = finalChartData[index - 1].y;
                                    const change = value - previousValue;
                                    
                                    if (change > 0) {
                                        changeHtml = ` <span style="color: #28a745; font-weight: bold;">+${change}</span>`;
                                    } else if (change < 0) {
                                        changeHtml = ` <span style="color: #dc3545; font-weight: bold;">${change}</span>`;
                                    } else {
                                        changeHtml = ` <span style="color: #b0b0b0;">0</span>`;
                                    }
                                }
                                
                                const title = date.toLocaleDateString('en-US', { 
                                    month: 'long', 
                                    day: 'numeric', 
                                    year: 'numeric' 
                                });
                                
                                tooltipEl.innerHTML = `
                                    <div style="font-weight: bold; color: #222; font-size: 1.1em; text-align: center; margin-bottom: 6px; border-bottom: 1px solid #dee2e6; padding-bottom: 6px;">${title}</div>
                                    <div style="color: #607890; text-align: center;">${value}${changeHtml}</div>
                                `;
                                
                                const position = chart.canvas.getBoundingClientRect();
                                
                                // Calculate tooltip position relative to viewport (since we're using position: fixed)
                                const left = position.left + tooltip.caretX;
                                const top = position.top + tooltip.caretY;
                                
                                tooltipEl.style.opacity = '1';
                                tooltipEl.style.left = left + 'px';
                                tooltipEl.style.top = top + 'px';
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: false
                            },
                            ticks: {
                                color: '#444',
                                callback: function(value) {
                                    // Remove commas from rating numbers - just return the number as string
                                    return value.toString();
                                }
                            },
                            grid: {
                                color: '#dee2e6'
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                displayFormats: {
                                    day: 'MMM d, yyyy'
                                },
                                tooltipFormat: 'MMM d, yyyy'
                            },
                            min: minDateWithPadding.getTime(),
                            max: maxDateWithPadding.getTime(),
                            title: {
                                display: false
                            },
                            offset: true,
                            bounds: 'data',
                            ticks: {
                                color: '#444',
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 12
                            },
                            grid: {
                                color: '#dee2e6'
                            }
                        }
                    }
                }
            });
        }
        
        function displayMatches(matches) {
            const tableDiv = document.getElementById('matchesTable');
            const statsDiv = document.getElementById('matchesStats');
            
            console.log('displayMatches called with:', matches);
            
            if (!matches || matches.length === 0) {
                console.log('No matches to display');
                tableDiv.innerHTML = '<div class="no-data">No matches found</div>';
                statsDiv.innerHTML = '';
                return;
            }
            
            // Calculate win/loss statistics (excluding draws)
            let wins = 0;
            let losses = 0;
            
            matches.forEach(match => {
                if (match.winner_name === playerName) {
                    wins++;
                } else if (match.winner_name && match.winner_name !== playerName) {
                    losses++;
                }
                // Draws are ignored
            });
            
            // Display statistics
            statsDiv.innerHTML = `
                <div class="head-to-head-stats">
                    <div class="h2h-stat h2h-stat-win">
                        <div class="value">${wins}</div>
                        <div class="label">Wins</div>
                    </div>
                    <div class="h2h-stat h2h-stat-loss">
                        <div class="value">${losses}</div>
                        <div class="label">Losses</div>
                    </div>
                </div>
            `;
            
            // Group matches by tournament_id
            const matchesByTournament = {};
            matches.forEach(match => {
                const tournamentId = match.tournament_id || 'no-tournament';
                if (!matchesByTournament[tournamentId]) {
                    matchesByTournament[tournamentId] = [];
                }
                matchesByTournament[tournamentId].push(match);
            });
            
            let html = '';
            
            // Process matches grouped by tournament
            Object.keys(matchesByTournament).forEach(tournamentId => {
                const tournamentMatches = matchesByTournament[tournamentId];
                const firstMatch = tournamentMatches[0];
                
                // Add tournament link above the table (not part of the table)
                if (firstMatch.tournament_id) {
                    html += `<div style="margin-top: 20px; margin-bottom: 10px;"><a href="/tournament/${firstMatch.tournament_id}" style="color: #607890; text-decoration: none; font-weight: 600; font-size: 1.1em;">View Tournament</a></div>`;
                }
                
                // Table for this tournament group
                html += '<table><thead><tr><th>Date</th><th>Opponent</th><th>Rating</th><th>Score</th><th>Result</th></tr></thead><tbody>';
                
                tournamentMatches.forEach((match) => {
                    console.log('Processing match:', match);
                    
                    const isPlayer1 = match.player1_name === playerName;
                    const opponent = isPlayer1 ? (match.player2_name || 'Unknown') : (match.player1_name || 'Unknown');
                    const playerScore = isPlayer1 ? (match.player1_score || 0) : (match.player2_score || 0);
                    const opponentScore = isPlayer1 ? (match.player2_score || 0) : (match.player1_score || 0);
                    const opponentRating = isPlayer1 ? match.player2_rating : match.player1_rating;
                    
                    // Determine winner from scores if winner_name is not set
                    let isWin = false;
                    let isLoss = false;
                    
                    if (match.winner_name) {
                        isWin = match.winner_name === playerName;
                        isLoss = match.winner_name && match.winner_name !== playerName;
                    } else {
                        // Fallback: determine from scores
                        if (playerScore > opponentScore) {
                            isWin = true;
                        } else if (playerScore < opponentScore) {
                            isLoss = true;
                        }
                    }
                    
                    let resultClass = '';
                    let resultText = 'Draw';
                    if (isWin) {
                        resultClass = 'win';
                        resultText = 'Win';
                    } else if (isLoss) {
                        resultClass = 'loss';
                        resultText = 'Loss';
                    }
                    
                    // Format date
                    let dateStr = match.tournament_date || 'N/A';
                    let dateDisplay = dateStr;
                    if (dateStr !== 'N/A' && dateStr) {
                        try {
                            const date = parseLocalDate(dateStr);
                            if (date && !isNaN(date.getTime())) {
                                dateDisplay = date.toLocaleDateString('en-US', { 
                                    month: 'short', 
                                    day: 'numeric', 
                                    year: 'numeric' 
                                });
                            }
                        } catch (e) {
                            console.error('Error parsing date:', dateStr, e);
                            // Keep original if parsing fails
                        }
                    }
                    
                    // Make date a link to tournament if tournament_id is available
                    const tournamentId = match.tournament_id;
                    const dateCell = tournamentId 
                        ? `<a href="/tournament/${tournamentId}" class="tournament-date-link">${dateDisplay}</a>`
                        : dateDisplay;
                    
                    // Format opponent rating
                    const opponentRatingStr = opponentRating !== null && opponentRating !== undefined ? opponentRating.toString() : 'N/A';
                    
                    html += `
                        <tr>
                            <td>${dateCell}</td>
                            <td>${createPlayerLink(opponent)}</td>
                            <td>${opponentRatingStr}</td>
                            <td>${playerScore}-${opponentScore}</td>
                            <td class="${resultClass}">${resultText}</td>
                        </tr>
                    `;
                });
                
                html += '</tbody></table>';
            });
            tableDiv.innerHTML = html;
            console.log('Matches table rendered');
        }
        
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            document.getElementById('loading').style.display = 'none';
        }
        
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function createPlayerLink(playerName) {
            if (!playerName || playerName === 'Unknown') {
                return escapeHtml(playerName || 'Unknown');
            }
            const encodedName = encodeURIComponent(playerName);
            return `<a href="/player/${encodedName}" style="color: #607890; text-decoration: none;">${escapeHtml(playerName)}</a>`;
        }
        
        async function loadTournamentCalendar() {
            try {
                const response = await fetch(`/api/player/${encodeURIComponent(playerName)}/tournament-calendar`);
                const data = await response.json();
                
                if (data.error) {
                    console.error('Error loading tournament calendar:', data.error);
                    return;
                }
                
                displayTournamentCalendar(data.tournaments || []);
            } catch (error) {
                console.error('Error loading tournament calendar:', error);
            }
        }
        
        function displayTournamentCalendar(tournaments) {
            const calendarDiv = document.getElementById('tournamentCalendar');
            
            if (!tournaments || tournaments.length === 0) {
                calendarDiv.innerHTML = '<div class="no-data">No tournament data available</div>';
                return;
            }
            
            // Parse all tournaments and find the first attended tournament
            const allTournaments = [];
            let firstAttendedYear = null;
            
            tournaments.forEach(tournament => {
                if (!tournament.tournament_date) return;
                
                const dateStr = tournament.tournament_date.split('T')[0]; // Get YYYY-MM-DD part
                const dateParts = dateStr.split('-');
                if (dateParts.length !== 3) return;
                
                const year = parseInt(dateParts[0]);
                const month = parseInt(dateParts[1]) - 1; // 0-indexed for Date
                const day = parseInt(dateParts[2]);
                
                if (isNaN(year) || isNaN(month) || isNaN(day)) return;
                
                const tournamentData = {
                    year: year,
                    month: month,
                    day: day,
                    date: new Date(year, month, day),
                    attended: tournament.attended || false,
                    tournament_id: tournament.tournament_id,
                    source_url: tournament.source_url
                };
                
                allTournaments.push(tournamentData);
                
                // Track first attended tournament year
                if (tournament.attended && (firstAttendedYear === null || year < firstAttendedYear)) {
                    firstAttendedYear = year;
                }
            });
            
            // Filter out years before first attended tournament
            const filteredTournaments = firstAttendedYear === null 
                ? allTournaments 
                : allTournaments.filter(t => t.year >= firstAttendedYear);
            
            if (filteredTournaments.length === 0) {
                calendarDiv.innerHTML = '<div class="no-data">No tournament data available</div>';
                return;
            }
            
            // Group tournaments by year
            const tournamentsByYear = {};
            filteredTournaments.forEach(t => {
                if (!tournamentsByYear[t.year]) {
                    tournamentsByYear[t.year] = [];
                }
                tournamentsByYear[t.year].push(t);
            });
            
            // Sort years descending
            const years = Object.keys(tournamentsByYear).map(y => parseInt(y)).sort((a, b) => b - a);
            
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            let html = '<div class="tournament-calendar">';
            
            years.forEach(year => {
                const yearTournaments = tournamentsByYear[year];
                
                // Group by month (0-11 for Jan-Dec)
                const tournamentsByMonth = {};
                yearTournaments.forEach(t => {
                    if (!tournamentsByMonth[t.month]) {
                        tournamentsByMonth[t.month] = [];
                    }
                    tournamentsByMonth[t.month].push(t);
                });
                
                // Sort dates within each month
                Object.keys(tournamentsByMonth).forEach(month => {
                    tournamentsByMonth[month].sort((a, b) => a.day - b.day);
                });
                
                html += `<div class="calendar-year"><h3>${year}</h3><div class="calendar-months">`;
                
                // Show all 12 months in order (Jan to Dec, left to right)
                for (let month = 0; month < 12; month++) {
                    const monthTournaments = tournamentsByMonth[month] || [];
                    
                    html += '<div class="calendar-month">';
                    html += `<div class="calendar-month-header">${monthNames[month]}</div>`;
                    html += '<div class="calendar-month-dates">';
                    
                    if (monthTournaments.length > 0) {
                        monthTournaments.forEach(t => {
                            const dateClass = t.attended ? 'attended' : 'not-attended';
                            const link = t.source_url || '#';
                            const dayStr = t.day.toString().padStart(2, '0');
                            const title = t.attended ? `Attended - ${monthNames[t.month]} ${t.day}, ${year}` : `Did not attend - ${monthNames[t.month]} ${t.day}, ${year}`;
                            html += `<a href="${link}" target="_blank" class="calendar-date ${dateClass}" title="${title}">${dayStr}</a>`;
                        });
                    }
                    
                    html += '</div></div>';
                }
                
                html += '</div></div>';
            });
            
            html += '</div>';
            calendarDiv.innerHTML = html;
        }
        
        // Section Navigation
        function initSectionNavigation() {
            const sectionNav = document.getElementById('sectionNav');
            const backToTop = document.getElementById('backToTop');
            const sections = document.querySelectorAll('.section-anchor');
            const navLinks = document.querySelectorAll('.section-nav-link');
            
            // Show/hide navigation based on scroll
            function handleScroll() {
                const scrollY = window.scrollY;
                
                // Show section nav after scrolling past header
                if (scrollY > 200) {
                    sectionNav.classList.add('show');
                } else {
                    sectionNav.classList.remove('show');
                }
                
                // Show back to top button
                if (scrollY > 500) {
                    backToTop.classList.add('show');
                } else {
                    backToTop.classList.remove('show');
                }
                
                // Update active section based on scroll position
                let currentSection = '';
                sections.forEach(section => {
                    const sectionTop = section.offsetTop - 100;
                    const sectionHeight = section.offsetHeight;
                    if (scrollY >= sectionTop && scrollY < sectionTop + sectionHeight) {
                        currentSection = section.id;
                    }
                });
                
                // Update active nav link
                navLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === '#' + currentSection) {
                        link.classList.add('active');
                    }
                });
            }
            
            // Smooth scroll for nav links
            navLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href').substring(1);
                    const targetSection = document.getElementById(targetId);
                    if (targetSection) {
                        const offsetTop = targetSection.offsetTop - 80;
                        window.scrollTo({
                            top: offsetTop,
                            behavior: 'smooth'
                        });
                    }
                });
            });
            
            // Back to top button
            backToTop.addEventListener('click', function() {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
            
            // Listen for scroll events
            window.addEventListener('scroll', handleScroll);
            handleScroll(); // Initial check
        }
        
        // Load data on page load
        loadPlayerData();
        
        // Initialize section navigation after content loads
        setTimeout(() => {
            initSectionNavigation();
        }, 500);
    </script>
</body>
</html>

