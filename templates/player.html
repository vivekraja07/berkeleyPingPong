<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ player_name }} - Statistics</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            background: #2d2d2d;
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        header h1 {
            color: #e0e0e0;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        header a {
            color: #7c9eff;
            text-decoration: none;
            font-weight: 600;
        }
        
        header a:hover {
            text-decoration: underline;
        }
        
        .stats-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card .value.small {
            font-size: 1.5em;
        }
        
        .stat-card .value.extra-small {
            font-size: 1.2em;
        }
        
        .stat-card .sub-info {
            font-size: 0.85em;
            color: #b0b0b0;
            margin-top: 5px;
        }
        
        .stat-card {
            background: #2d2d2d;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            text-align: center;
        }
        
        .stat-card .value {
            font-size: 2.5em;
            font-weight: bold;
            color: #7c9eff;
            margin-bottom: 10px;
        }
        
        .stat-card.wins .value {
            color: #28a745;
        }
        
        .stat-card.losses .value {
            color: #dc3545;
        }
        
        .stat-card .label {
            color: #b0b0b0;
            font-size: 1.1em;
        }
        
        .chart-container {
            background: #2d2d2d;
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .chart-container h2 {
            color: #e0e0e0;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        
        .chart-wrapper {
            position: relative;
            height: 400px;
            margin-bottom: 20px;
        }
        
        .matches-table {
            background: #2d2d2d;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            overflow-x: auto;
        }
        
        .matches-table h2 {
            color: #e0e0e0;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        
        .timeline-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .timeline-btn {
            padding: 8px 16px;
            border: 2px solid #7c9eff;
            background: #2d2d2d;
            color: #7c9eff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .timeline-btn:hover {
            background: #3d3d3d;
        }
        
        .timeline-btn.active {
            background: #7c9eff;
            color: #1a1a1a;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #404040;
            color: #e0e0e0;
        }
        
        th {
            background: #3d3d3d;
            font-weight: 600;
            color: #e0e0e0;
        }
        
        tr:hover {
            background: #3d3d3d;
        }
        
        .win {
            color: #28a745;
            font-weight: 600;
        }
        
        .loss {
            color: #dc3545;
            font-weight: 600;
        }
        
        .loading {
            text-align: center;
            color: white;
            font-size: 1.2em;
            padding: 40px;
        }
        
        .error {
            background: #ff6b6b;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .no-data {
            text-align: center;
            color: #b0b0b0;
            padding: 40px;
            font-size: 1.1em;
        }
        
        .pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding: 15px 0;
            border-top: 1px solid #404040;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        @media (max-width: 768px) {
            .pagination {
                flex-direction: column;
                align-items: stretch;
            }
            
            .pagination-info {
                text-align: center;
            }
            
            .pagination-controls {
                justify-content: center;
            }
        }
        
        .pagination-info {
            color: #b0b0b0;
            font-size: 0.9em;
        }
        
        .pagination-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .pagination-btn {
            padding: 8px 16px;
            border: 2px solid #7c9eff;
            background: #2d2d2d;
            color: #7c9eff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .pagination-btn:hover:not(:disabled) {
            background: #3d3d3d;
        }
        
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination-btn.active {
            background: #7c9eff;
            color: #1a1a1a;
        }
        
        .page-numbers {
            display: flex;
            gap: 5px;
        }
        
        .page-number {
            min-width: 36px;
            padding: 8px 12px;
            border: 2px solid #7c9eff;
            background: #2d2d2d;
            color: #7c9eff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            text-align: center;
            transition: all 0.3s;
        }
        
        .page-number:hover {
            background: #3d3d3d;
        }
        
        .page-number.active {
            background: #7c9eff;
            color: #1a1a1a;
        }
        
        .tournament-selector {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .head-to-head-selector {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .opponent-select {
            padding: 10px 15px;
            border: 2px solid #7c9eff;
            background: #2d2d2d;
            color: #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            min-width: 250px;
            transition: all 0.3s;
        }
        
        .opponent-select:hover {
            background: #3d3d3d;
        }
        
        .opponent-select:focus {
            outline: none;
            border-color: #9cb4ff;
        }
        
        .opponent-select option {
            background: #2d2d2d;
            color: #e0e0e0;
        }
        
        .head-to-head-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: #3d3d3d;
            border-radius: 8px;
        }
        
        .h2h-stat {
            text-align: center;
        }
        
        .h2h-stat .value {
            font-size: 2em;
            font-weight: bold;
            color: #7c9eff;
            margin-bottom: 5px;
        }
        
        .h2h-stat .label {
            color: #b0b0b0;
            font-size: 0.9em;
        }
        
        .h2h-stat-win .value {
            color: #28a745;
        }
        
        .h2h-stat-loss .value {
            color: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üèì {{ player_name }}</h1>
            <a href="/">‚Üê Back to All Players</a>
        </header>
        
        <div id="loading" class="loading">Loading statistics...</div>
        <div id="error" class="error" style="display: none;"></div>
        
        <div id="content" style="display: none;">
            <div class="stats-cards" id="statsCards"></div>
            
            <div class="chart-container">
                <h2>Rating Over Time <span id="ratingChangeIndicator" style="font-size: 0.7em; font-weight: normal; margin-left: 10px;"></span></h2>
                <div class="timeline-selector">
                    <button class="timeline-btn" data-days="180" onclick="updateChart(180)">6 Months</button>
                    <button class="timeline-btn" data-days="365" onclick="updateChart(365)">1 Year</button>
                    <button class="timeline-btn active" data-days="null" onclick="updateChart(null)">All Time</button>
                </div>
                <div class="chart-wrapper">
                    <canvas id="ratingChart"></canvas>
                </div>
            </div>
            
            <div class="matches-table">
                <h2>Recent Matches</h2>
                <div class="tournament-selector">
                    <label for="tournamentSelect" style="color: #b0b0b0; margin-right: 10px;">Tournament:</label>
                    <select id="tournamentSelect" class="opponent-select">
                        <option value="">-- Loading tournaments --</option>
                    </select>
                </div>
                <div id="matchesStats" style="margin-bottom: 20px;"></div>
                <div id="matchesTable"></div>
                <div id="pagination" class="pagination" style="display: none;"></div>
            </div>
            
            <div class="matches-table" style="margin-top: 30px;">
                <h2>Head-to-Head</h2>
                <div class="head-to-head-selector">
                    <label for="opponentSelect" style="color: #b0b0b0; margin-right: 10px;">Select Opponent:</label>
                    <select id="opponentSelect" class="opponent-select">
                        <option value="">-- Loading opponents --</option>
                    </select>
                </div>
                <div id="headToHeadTable" style="margin-top: 20px;"></div>
            </div>
        </div>
    </div>
    
    <script>
        const playerName = {{ player_name|tojson }};
        let ratingChart = null;
        let allRatingData = null;
        let currentPage = 1;
        let chartDaysBack = null; // Default to all time
        let currentDaysBack = null; // No filter for matches
        let currentTournamentId = null; // Current tournament filter
        let pageSize = 20;
        let totalMatches = 0;
        let totalPages = 0;
        let tournaments = [];
        let opponentSelectListenerAdded = false;
        
        async function loadPlayerData() {
            try {
                // Show content immediately (progressive loading)
                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';
                
                // Load critical data first (stats and charts)
                const criticalPromises = [
                    fetch(`/api/player/${encodeURIComponent(playerName)}/rating-history`).then(r => r.json()),
                    fetch(`/api/player/${encodeURIComponent(playerName)}/match-stats`).then(r => r.json()),
                    fetch(`/api/player/${encodeURIComponent(playerName)}/tournaments`).then(r => r.json())
                ];
                
                const [ratingHistory, matchStats, tournamentsData] = await Promise.all(criticalPromises);
                
                // Check for errors in critical data
                if (ratingHistory.error || matchStats.error || tournamentsData.error) {
                    showError(ratingHistory.error || matchStats.error || tournamentsData.error);
                    return;
                }
                
                // Display critical data immediately
                allRatingData = ratingHistory;
                
                // Debug: log the stats from initial load
                console.log('=== INITIAL STATS DEBUG ===');
                console.log('Full stats object:', JSON.stringify(matchStats, null, 2));
                console.log('Highest rating:', matchStats.highest_rating, 'Type:', typeof matchStats.highest_rating);
                console.log('Top rated win:', matchStats.top_rated_win, 'Type:', typeof matchStats.top_rated_win);
                console.log('Date joined:', matchStats.date_joined, 'Type:', typeof matchStats.date_joined);
                console.log('Last match date:', matchStats.last_match_date, 'Type:', typeof matchStats.last_match_date);
                if (matchStats._debug) {
                    console.log('Debug info:', matchStats._debug);
                }
                console.log('==========================');
                
                displayStats(matchStats);
                displayRatingChart(ratingHistory, chartDaysBack);
                
                // Initialize chartDaysBack if not set (default to all time)
                if (chartDaysBack === undefined) {
                    chartDaysBack = null;
                }
                
                // Store tournaments and populate dropdown
                tournaments = tournamentsData.tournaments || [];
                populateTournamentDropdown(tournaments);
                
                // Load opponents in background (non-blocking)
                loadOpponents();
            } catch (error) {
                showError('Failed to load player data: ' + error.message);
            }
        }
        
        async function loadOpponents() {
            try {
                const response = await fetch(`/api/player/${encodeURIComponent(playerName)}/opponents`);
                const opponents = await response.json();
                
                if (opponents.error) {
                    console.error('Error loading opponents:', opponents.error);
                    return;
                }
                
                // Populate opponent dropdown and auto-select most frequent opponent
                populateOpponentDropdown(opponents.opponents || []);
            } catch (error) {
                console.error('Error loading opponents:', error);
            }
        }
        
        function populateTournamentDropdown(tournaments) {
            const select = document.getElementById('tournamentSelect');
            
            // Clear existing options
            select.innerHTML = '';
            
            // Add "All Tournaments" option
            const allOption = document.createElement('option');
            allOption.value = '';
            allOption.textContent = 'All Tournaments';
            select.appendChild(allOption);
            
            if (!tournaments || tournaments.length === 0) {
                return;
            }
            
            // Add tournaments (already sorted by date descending)
            tournaments.forEach(tournament => {
                const option = document.createElement('option');
                option.value = tournament.tournament_id;
                const dateStr = tournament.tournament_date || '';
                option.textContent = dateStr || 'Unknown Date';
                select.appendChild(option);
            });
            
            // Auto-select the first tournament (latest)
            if (tournaments.length > 0) {
                const latestTournamentId = tournaments[0].tournament_id;
                select.value = latestTournamentId;
                currentTournamentId = latestTournamentId;
                
                // Load matches for the latest tournament
                loadMatches(1);
            } else {
                // No tournaments, load all matches
                loadMatches(1);
            }
            
            // Add event listener for selection change
            select.addEventListener('change', function() {
                const tournamentId = this.value ? parseInt(this.value) : null;
                currentTournamentId = tournamentId;
                currentPage = 1; // Reset to first page
                loadMatches(1);
            });
        }
        
        function populateOpponentDropdown(opponents) {
            const select = document.getElementById('opponentSelect');
            
            // Clear existing options
            select.innerHTML = '';
            
            if (!opponents || opponents.length === 0) {
                // No opponents found
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '-- No opponents found --';
                select.appendChild(option);
                return;
            }
            
            // Add opponents (already sorted by match count descending)
            opponents.forEach(opponent => {
                const opponentName = opponent.name || opponent;
                const matchCount = opponent.match_count || 0;
                const option = document.createElement('option');
                option.value = opponentName;
                option.textContent = `${opponentName} (${matchCount} match${matchCount !== 1 ? 'es' : ''})`;
                select.appendChild(option);
            });
            
            // Auto-select the first opponent (most frequent)
            const firstOpponent = opponents[0].name || opponents[0];
            select.value = firstOpponent;
            
            // Load head-to-head matches for the most frequent opponent
            loadHeadToHeadMatches(firstOpponent);
            
            // Add event listener for selection change (only once)
            if (!opponentSelectListenerAdded) {
                select.addEventListener('change', function() {
                    const opponentName = this.value;
                    if (opponentName) {
                        loadHeadToHeadMatches(opponentName);
                    } else {
                        document.getElementById('headToHeadTable').innerHTML = '';
                    }
                });
                opponentSelectListenerAdded = true;
            }
        }
        
        async function loadHeadToHeadMatches(opponentName) {
            try {
                const response = await fetch(`/api/player/${encodeURIComponent(playerName)}/vs/${encodeURIComponent(opponentName)}`);
                const data = await response.json();
                
                if (data.error) {
                    showError(data.error);
                    return;
                }
                
                displayHeadToHeadMatches(data.matches || [], opponentName);
            } catch (error) {
                console.error('Error loading head-to-head matches:', error);
                showError('Failed to load head-to-head matches: ' + error.message);
            }
        }
        
        function displayHeadToHeadMatches(matches, opponentName) {
            const tableDiv = document.getElementById('headToHeadTable');
            
            if (!matches || matches.length === 0) {
                tableDiv.innerHTML = '<div class="no-data">No matches found between ' + escapeHtml(playerName) + ' and ' + escapeHtml(opponentName) + '</div>';
                return;
            }
            
            // Calculate head-to-head statistics (excluding draws)
            let playerWins = 0;
            let opponentWins = 0;
            
            matches.forEach(match => {
                if (match.winner_name === playerName) {
                    playerWins++;
                } else if (match.winner_name === opponentName) {
                    opponentWins++;
                }
                // Draws are ignored
            });
            
            // Display statistics
            let html = `
                <div class="head-to-head-stats">
                    <div class="h2h-stat h2h-stat-win">
                        <div class="value">${playerWins}</div>
                        <div class="label">${escapeHtml(playerName)} Wins</div>
                    </div>
                    <div class="h2h-stat h2h-stat-loss">
                        <div class="value">${opponentWins}</div>
                        <div class="label">${escapeHtml(opponentName)} Wins</div>
                    </div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>${escapeHtml(playerName)}</th>
                            <th>Rating</th>
                            <th>Score</th>
                            <th>Rating</th>
                            <th>${escapeHtml(opponentName)}</th>
                            <th>Result</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            matches.forEach(match => {
                const isPlayer1 = match.player1_name === playerName;
                const playerScore = isPlayer1 ? match.player1_score : match.player2_score;
                const opponentScore = isPlayer1 ? match.player2_score : match.player1_score;
                const playerRating = isPlayer1 ? match.player1_rating : match.player2_rating;
                const opponentRating = isPlayer1 ? match.player2_rating : match.player1_rating;
                
                // Determine winner
                let resultClass = '';
                let resultText = 'Draw';
                if (match.winner_name === playerName) {
                    resultClass = 'win';
                    resultText = 'Win';
                } else if (match.winner_name === opponentName) {
                    resultClass = 'loss';
                    resultText = 'Loss';
                }
                
                // Format date
                let dateStr = match.tournament_date || 'N/A';
                if (dateStr !== 'N/A' && dateStr) {
                    try {
                        const date = new Date(dateStr);
                        if (!isNaN(date.getTime())) {
                            dateStr = date.toLocaleDateString('en-US', { 
                                month: 'short', 
                                day: 'numeric', 
                                year: 'numeric' 
                            });
                        }
                    } catch (e) {
                        // Keep original if parsing fails
                    }
                }
                
                // Format ratings
                const playerRatingStr = playerRating !== null && playerRating !== undefined ? playerRating.toString() : 'N/A';
                const opponentRatingStr = opponentRating !== null && opponentRating !== undefined ? opponentRating.toString() : 'N/A';
                
                html += `
                    <tr>
                        <td>${dateStr}</td>
                        <td>${escapeHtml(playerName)}</td>
                        <td>${playerRatingStr}</td>
                        <td>${playerScore || 0}-${opponentScore || 0}</td>
                        <td>${opponentRatingStr}</td>
                        <td>${escapeHtml(opponentName)}</td>
                        <td class="${resultClass}">${resultText}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            tableDiv.innerHTML = html;
        }
        
        async function loadMatches(page = 1) {
            // Update state
            currentPage = page;
            
            try {
                let url = `/api/player/${encodeURIComponent(playerName)}/matches?page=${page}&page_size=${pageSize}`;
                
                // Add tournament filter if selected
                if (currentTournamentId !== null && currentTournamentId !== undefined) {
                    url += `&tournament_id=${currentTournamentId}`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                console.log('Matches API response:', data);
                
                if (data.error) {
                    console.error('Matches API error:', data.error);
                    showError(data.error);
                    return;
                }
                
                // Update pagination state
                totalMatches = data.total || 0;
                totalPages = data.total_pages || 0;
                currentPage = data.page || page;
                
                const matches = data.matches || [];
                console.log(`Found ${matches.length} matches (page ${currentPage} of ${totalPages})`);
                
                displayMatches(matches);
                displayPagination(data);
            } catch (error) {
                console.error('Error loading matches:', error);
                showError('Failed to load matches: ' + error.message);
            }
        }
        
        function goToPage(page) {
            if (page >= 1 && page <= totalPages) {
                loadMatches(page);
            }
        }
        
        async function updateChart(daysBack) {
            // Update active button
            document.querySelectorAll('.timeline-selector .timeline-btn').forEach(btn => {
                btn.classList.remove('active');
                const btnDays = btn.getAttribute('data-days');
                if ((daysBack === null && btnDays === 'null') || 
                    (daysBack !== null && btnDays === String(daysBack))) {
                    btn.classList.add('active');
                }
            });
            
            // Update chart filter
            chartDaysBack = daysBack;
            
            // Re-render chart with filtered data
            if (allRatingData) {
                displayRatingChart(allRatingData, daysBack);
            }
            
            // Update stats based on timespan
            await updateStats(daysBack);
        }
        
        async function updateStats(daysBack) {
            try {
                let url = `/api/player/${encodeURIComponent(playerName)}/match-stats`;
                if (daysBack !== null && daysBack !== undefined) {
                    url += `?days_back=${daysBack}`;
                }
                
                const response = await fetch(url);
                const stats = await response.json();
                
                if (stats.error) {
                    console.error('Error loading stats:', stats.error);
                    return;
                }
                
                // Debug: log the stats to see what we're getting
                console.log('=== STATS DEBUG ===');
                console.log('Full stats object:', JSON.stringify(stats, null, 2));
                console.log('Highest rating:', stats.highest_rating, 'Type:', typeof stats.highest_rating);
                console.log('Top rated win:', stats.top_rated_win, 'Type:', typeof stats.top_rated_win);
                console.log('Date joined:', stats.date_joined, 'Type:', typeof stats.date_joined);
                console.log('Last match date:', stats.last_match_date, 'Type:', typeof stats.last_match_date);
                if (stats._debug) {
                    console.log('Debug info:', stats._debug);
                }
                console.log('==================');
                
                displayStats(stats);
            } catch (error) {
                console.error('Error updating stats:', error);
            }
        }
        
        function displayPagination(data) {
            const paginationDiv = document.getElementById('pagination');
            
            if (!data || data.total === 0 || data.total_pages <= 1) {
                paginationDiv.style.display = 'none';
                return;
            }
            
            paginationDiv.style.display = 'flex';
            
            const page = data.page || 1;
            const total = data.total || 0;
            const totalPages = data.total_pages || 0;
            const pageSize = data.page_size || 20;
            
            const start = (page - 1) * pageSize + 1;
            const end = Math.min(page * pageSize, total);
            
            // Calculate page numbers to show
            const maxPagesToShow = 7;
            let startPage = Math.max(1, page - Math.floor(maxPagesToShow / 2));
            let endPage = Math.min(totalPages, startPage + maxPagesToShow - 1);
            
            if (endPage - startPage < maxPagesToShow - 1) {
                startPage = Math.max(1, endPage - maxPagesToShow + 1);
            }
            
            let html = `
                <div class="pagination-info">
                    Showing ${start}-${end} of ${total} matches
                </div>
                <div class="pagination-controls">
                    <button class="pagination-btn" onclick="goToPage(${page - 1})" ${page === 1 ? 'disabled' : ''}>
                        Previous
                    </button>
                    <div class="page-numbers">
            `;
            
            // First page
            if (startPage > 1) {
                html += `<span class="page-number ${1 === page ? 'active' : ''}" onclick="goToPage(1)">1</span>`;
                if (startPage > 2) {
                    html += `<span class="page-number" style="cursor: default; border: none;">...</span>`;
                }
            }
            
            // Page numbers
            for (let i = startPage; i <= endPage; i++) {
                html += `<span class="page-number ${i === page ? 'active' : ''}" onclick="goToPage(${i})">${i}</span>`;
            }
            
            // Last page
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    html += `<span class="page-number" style="cursor: default; border: none;">...</span>`;
                }
                html += `<span class="page-number ${totalPages === page ? 'active' : ''}" onclick="goToPage(${totalPages})">${totalPages}</span>`;
            }
            
            html += `
                    </div>
                    <button class="pagination-btn" onclick="goToPage(${page + 1})" ${page === totalPages ? 'disabled' : ''}>
                        Next
                    </button>
                </div>
            `;
            
            paginationDiv.innerHTML = html;
        }
        
        function displayStats(stats) {
            const cards = document.getElementById('statsCards');
            
            // Debug: log what we're displaying
            console.log('displayStats called with:', stats);
            console.log('highest_rating:', stats.highest_rating);
            console.log('top_rated_win:', stats.top_rated_win);
            console.log('date_joined:', stats.date_joined);
            console.log('last_match_date:', stats.last_match_date);
            
            // Format date helper
            function formatDate(dateStr) {
                if (!dateStr) return 'N/A';
                try {
                    const date = new Date(dateStr);
                    if (!isNaN(date.getTime())) {
                        return date.toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric', 
                            year: 'numeric' 
                        });
                    }
                } catch (e) {
                    // Keep original if parsing fails
                }
                return dateStr;
            }
            
            cards.innerHTML = `
                <div class="stat-card">
                    <div class="value">${stats.total_tournaments || 0}</div>
                    <div class="label">Total Tournaments Attended</div>
                </div>
                <div class="stat-card wins">
                    <div class="value">${stats.wins || 0}</div>
                    <div class="label">Wins</div>
                </div>
                <div class="stat-card losses">
                    <div class="value">${stats.losses || 0}</div>
                    <div class="label">Losses</div>
                </div>
                <div class="stat-card">
                    <div class="value">${(stats.win_percentage || 0).toFixed(1)}%</div>
                    <div class="label">Win Percentage</div>
                </div>
                <div class="stat-card">
                    <div class="value">${(stats.highest_rating !== null && stats.highest_rating !== undefined && stats.highest_rating !== '') ? stats.highest_rating : 'N/A'}</div>
                    <div class="label">Highest Rating</div>
                </div>
                <div class="stat-card">
                    <div class="value ${stats.top_rated_win_info ? 'extra-small' : ''}">${(stats.top_rated_win !== null && stats.top_rated_win !== undefined && stats.top_rated_win !== '') ? stats.top_rated_win : 'N/A'}</div>
                    <div class="label">Top Rated Win</div>
                    ${stats.top_rated_win_info ? `
                        <div class="sub-info">${escapeHtml(stats.top_rated_win_info.opponent_name || 'Unknown')}</div>
                        <div class="sub-info">${formatDate(stats.top_rated_win_info.date)}</div>
                    ` : ''}
                </div>
                <div class="stat-card">
                    <div class="value small">${formatDate(stats.date_joined)}</div>
                    <div class="label">Date Joined</div>
                </div>
                <div class="stat-card">
                    <div class="value small">${formatDate(stats.last_match_date)}</div>
                    <div class="label">Last Match</div>
                </div>
            `;
        }
        
        function displayRatingChart(data, daysBack = null) {
            const ctx = document.getElementById('ratingChart').getContext('2d');
            
            if (!data.chart_data || !data.chart_data.labels || data.chart_data.labels.length === 0) {
                document.getElementById('ratingChart').parentElement.innerHTML = 
                    '<div class="no-data">No rating history available</div>';
                return;
            }
            
            if (ratingChart) {
                ratingChart.destroy();
            }
            
            // Create continuous time axis using time scale
            const rawData = data.raw_data || [];
            if (rawData.length === 0) {
                document.getElementById('ratingChart').parentElement.innerHTML = 
                    '<div class="no-data">No rating history available</div>';
                return;
            }
            
            // Filter by date if daysBack is provided
            let filteredData = rawData;
            if (daysBack !== null && daysBack !== undefined) {
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - daysBack);
                filteredData = rawData.filter(entry => {
                    const dateStr = entry.tournament_date || entry.date;
                    if (!dateStr) return false;
                    const entryDate = new Date(dateStr);
                    return entryDate >= cutoffDate;
                });
            }
            
            if (filteredData.length === 0) {
                document.getElementById('ratingChart').parentElement.innerHTML = 
                    '<div class="no-data">No rating history available for selected time period</div>';
                return;
            }
            
            // Parse dates and ratings
            const chartData = filteredData.map(entry => {
                const dateStr = entry.tournament_date || entry.date;
                if (!dateStr) return null;
                return {
                    x: new Date(dateStr),
                    y: entry.rating_post
                };
            }).filter(d => d !== null && d.y !== null && d.y !== undefined);
            
            if (chartData.length === 0) {
                document.getElementById('ratingChart').parentElement.innerHTML = 
                    '<div class="no-data">No rating history available</div>';
                return;
            }
            
            // Sort by date
            chartData.sort((a, b) => a.x - b.x);
            
            // Calculate rating change in the selected timeframe
            let ratingChange = 0;
            let ratingChangeText = '';
            const ratingChangeIndicator = document.getElementById('ratingChangeIndicator');
            
            if (chartData.length > 0) {
                // Get first and last rating in the sorted chart data (chronologically)
                const firstRating = chartData[0].y;
                const lastRating = chartData[chartData.length - 1].y;
                
                if (firstRating !== null && firstRating !== undefined && 
                    lastRating !== null && lastRating !== undefined) {
                    ratingChange = lastRating - firstRating;
                    
                    if (ratingChange > 0) {
                        ratingChangeText = `<span style="color: #28a745;">+${ratingChange} points</span>`;
                    } else if (ratingChange < 0) {
                        ratingChangeText = `<span style="color: #dc3545;">${ratingChange} points</span>`;
                    } else {
                        ratingChangeText = `<span style="color: #b0b0b0;">0 points</span>`;
                    }
                }
            }
            
            // Display rating change indicator
            if (ratingChangeIndicator) {
                ratingChangeIndicator.innerHTML = ratingChangeText || '';
            }
            
            // Get min and max dates for axis bounds
            const dates = chartData.map(d => d.x);
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));
            
            // Add small padding for cleaner appearance (about 2% of date range)
            const dateRange = maxDate - minDate;
            const padding = dateRange * 0.02; // 2% padding
            const minDateWithPadding = new Date(minDate.getTime() - padding);
            const maxDateWithPadding = new Date(maxDate.getTime() + padding);
            
            ratingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Rating',
                        data: chartData,
                        borderColor: '#7c9eff',
                        backgroundColor: 'rgba(124, 158, 255, 0.2)',
                        tension: 0.1,
                        fill: true,
                        spanGaps: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: '#2d2d2d',
                            titleColor: '#e0e0e0',
                            bodyColor: '#e0e0e0',
                            borderColor: '#7c9eff',
                            borderWidth: 1,
                            callbacks: {
                                title: function(context) {
                                    const date = new Date(context[0].parsed.x);
                                    return date.toLocaleDateString('en-US', { 
                                        month: 'long', 
                                        day: 'numeric', 
                                        year: 'numeric' 
                                    });
                                },
                                label: function(context) {
                                    // Remove "Rating" label and commas from the value
                                    const value = context.parsed.y;
                                    return value.toString();
                                },
                                labelTextColor: function() {
                                    return '#7c9eff';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: false
                            },
                            ticks: {
                                color: '#b0b0b0',
                                callback: function(value) {
                                    // Remove commas from rating numbers - just return the number as string
                                    return value.toString();
                                }
                            },
                            grid: {
                                color: '#404040'
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                displayFormats: {
                                    day: 'MMM d, yyyy'
                                },
                                tooltipFormat: 'MMM d, yyyy'
                            },
                            min: minDateWithPadding.getTime(),
                            max: maxDateWithPadding.getTime(),
                            title: {
                                display: false
                            },
                            offset: true,
                            bounds: 'data',
                            ticks: {
                                color: '#b0b0b0',
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 12
                            },
                            grid: {
                                color: '#404040'
                            }
                        }
                    }
                }
            });
        }
        
        function displayMatches(matches) {
            const tableDiv = document.getElementById('matchesTable');
            const statsDiv = document.getElementById('matchesStats');
            
            console.log('displayMatches called with:', matches);
            
            if (!matches || matches.length === 0) {
                console.log('No matches to display');
                tableDiv.innerHTML = '<div class="no-data">No matches found</div>';
                statsDiv.innerHTML = '';
                return;
            }
            
            // Calculate win/loss statistics (excluding draws)
            let wins = 0;
            let losses = 0;
            
            matches.forEach(match => {
                if (match.winner_name === playerName) {
                    wins++;
                } else if (match.winner_name && match.winner_name !== playerName) {
                    losses++;
                }
                // Draws are ignored
            });
            
            // Display statistics
            statsDiv.innerHTML = `
                <div class="head-to-head-stats">
                    <div class="h2h-stat h2h-stat-win">
                        <div class="value">${wins}</div>
                        <div class="label">Wins</div>
                    </div>
                    <div class="h2h-stat h2h-stat-loss">
                        <div class="value">${losses}</div>
                        <div class="label">Losses</div>
                    </div>
                </div>
            `;
            
            let html = '<table><thead><tr><th>Date</th><th>Opponent</th><th>Rating</th><th>Score</th><th>Result</th></tr></thead><tbody>';
            
            matches.forEach(match => {
                console.log('Processing match:', match);
                
                const isPlayer1 = match.player1_name === playerName;
                const opponent = isPlayer1 ? (match.player2_name || 'Unknown') : (match.player1_name || 'Unknown');
                const playerScore = isPlayer1 ? (match.player1_score || 0) : (match.player2_score || 0);
                const opponentScore = isPlayer1 ? (match.player2_score || 0) : (match.player1_score || 0);
                const opponentRating = isPlayer1 ? match.player2_rating : match.player1_rating;
                
                // Determine winner from scores if winner_name is not set
                let isWin = false;
                let isLoss = false;
                
                if (match.winner_name) {
                    isWin = match.winner_name === playerName;
                    isLoss = match.winner_name && match.winner_name !== playerName;
                } else {
                    // Fallback: determine from scores
                    if (playerScore > opponentScore) {
                        isWin = true;
                    } else if (playerScore < opponentScore) {
                        isLoss = true;
                    }
                }
                
                let resultClass = '';
                let resultText = 'Draw';
                if (isWin) {
                    resultClass = 'win';
                    resultText = 'Win';
                } else if (isLoss) {
                    resultClass = 'loss';
                    resultText = 'Loss';
                }
                
                // Format date
                let dateStr = match.tournament_date || 'N/A';
                if (dateStr !== 'N/A' && dateStr) {
                    try {
                        const date = new Date(dateStr);
                        if (!isNaN(date.getTime())) {
                            dateStr = date.toLocaleDateString('en-US', { 
                                month: 'short', 
                                day: 'numeric', 
                                year: 'numeric' 
                            });
                        }
                    } catch (e) {
                        console.error('Error parsing date:', dateStr, e);
                        // Keep original if parsing fails
                    }
                }
                
                // Format opponent rating
                const opponentRatingStr = opponentRating !== null && opponentRating !== undefined ? opponentRating.toString() : 'N/A';
                
                html += `
                    <tr>
                        <td>${dateStr}</td>
                        <td>${escapeHtml(opponent)}</td>
                        <td>${opponentRatingStr}</td>
                        <td>${playerScore}-${opponentScore}</td>
                        <td class="${resultClass}">${resultText}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            tableDiv.innerHTML = html;
            console.log('Matches table rendered');
        }
        
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            document.getElementById('loading').style.display = 'none';
        }
        
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Load data on page load
        loadPlayerData();
    </script>
</body>
</html>

